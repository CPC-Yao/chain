package backend_test

import (
	"errors"
	"fmt"
	"math/big"
	"reflect"
	"testing"

	"bitbucket.org/cpchain/chain/accounts"
	"bitbucket.org/cpchain/chain/accounts/keystore"
	"bitbucket.org/cpchain/chain/consensus"
	"bitbucket.org/cpchain/chain/consensus/dpor"
	"bitbucket.org/cpchain/chain/consensus/dpor/backend"
	"bitbucket.org/cpchain/chain/core"
	"bitbucket.org/cpchain/chain/core/vm"
	"bitbucket.org/cpchain/chain/database"
	"bitbucket.org/cpchain/chain/types"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/crypto"
)

const (
	validatorNum = 4  // the number of validators in the committee
	caseSize     = 50 // a pre-defined const indicating the size of cases in a test function
)

// This function is to test DporStateMachine.Fsm with regarding to the normal cases
func TestDporStateMachine_Fsm(t *testing.T) {

	// t.Skip("Skip!")

	// About to create an emulated chain for testing

	// n refers the number of fake blocks generated by fate engine
	n := 5

	// The 2nd signer is the first proposer
	proposerAddr1, proposerKey1 := loadDefaultAccount(4)
	validatorAddr1, validatorKey1 := loadDefaultAccount(9)
	validatorAddr2, validatorKey2 := loadDefaultAccount(10)
	validatorAddr3, validatorKey3 := loadDefaultAccount(11)
	validatorAddr4, validatorKey4 := loadDefaultAccount(1)

	//_, _ = validatorAddr1, validatorKey1

	for i := 0; i <= 11; i++ {
		j := i
		//if i == 10 {
		//	j = 1
		//}
		if i == 5 || i == 6 {
			continue
		}
		addrTemp, err := loadDefaultAccount(j)
		if err != nil {
			fmt.Println(j, "addr hex:", addrTemp.Hex(), "addr Bytes:", addrTemp)
		}
	}

	// create fake key store for the proposer and four validators
	proposerFakeKeyStore := newFakeKeyStore(proposerAddr1, proposerKey1)
	validatorFakeKeyStore1 := newFakeKeyStore(validatorAddr1, validatorKey1)
	validatorFakeKeyStore2 := newFakeKeyStore(validatorAddr2, validatorKey2)
	validatorFakeKeyStore3 := newFakeKeyStore(validatorAddr3, validatorKey3)
	validatorFakeKeyStore4 := newFakeKeyStore(validatorAddr4, validatorKey4)

	// create a dataabse for the proposer and four validators
	proposerDb := database.NewMemDatabase()
	validatorDb1 := database.NewMemDatabase()
	validatorDb2 := database.NewMemDatabase()
	validatorDb3 := database.NewMemDatabase()
	validatorDb4 := database.NewMemDatabase()

	proposerRemoteDb := database.NewIpfsDbWithAdapter(database.NewFakeIpfsAdapter())
	validatorRemoteDb1 := database.NewIpfsDbWithAdapter(database.NewFakeIpfsAdapter())
	validatorRemoteDb2 := database.NewIpfsDbWithAdapter(database.NewFakeIpfsAdapter())
	validatorRemoteDb3 := database.NewIpfsDbWithAdapter(database.NewFakeIpfsAdapter())
	validatorRemoteDb4 := database.NewIpfsDbWithAdapter(database.NewFakeIpfsAdapter())

	gspec := core.DefaultGenesisBlock()
	gspec.Alloc = core.GenesisAlloc{
		proposerAddr1: {Balance: big.NewInt(1000000000000)},
	}
	proposerGenesis := gspec.MustCommit(proposerDb)
	validatorGenesis1 := gspec.MustCommit(validatorDb1)
	validatorGenesis2 := gspec.MustCommit(validatorDb2)
	validatorGenesis3 := gspec.MustCommit(validatorDb3)
	validatorGenesis4 := gspec.MustCommit(validatorDb4)

	config := gspec.Config
	dporConfig := config.Dpor

	// dpor.NewPbftFaker() create a dpor Engine in which circumvents verifying the legality of proposer
	// TODO: @shiyc a better testing should avoid adopting NewPbftFaker method
	proposerDporEngine := dpor.NewPbftFaker(dporConfig, proposerDb)
	proposerDporEngine.Authorize(proposerFakeKeyStore.addr, proposerFakeKeyStore.SignHash)

	validatorDporEngine1 := dpor.NewPbftFaker(dporConfig, validatorDb1)
	validatorDporEngine1.Authorize(validatorFakeKeyStore1.addr, validatorFakeKeyStore1.SignHash)

	validatorDporEngine2 := dpor.NewPbftFaker(dporConfig, validatorDb2)
	validatorDporEngine2.Authorize(validatorFakeKeyStore2.addr, validatorFakeKeyStore2.SignHash)

	validatorDporEngine3 := dpor.NewPbftFaker(dporConfig, validatorDb3)
	validatorDporEngine3.Authorize(validatorFakeKeyStore3.addr, validatorFakeKeyStore3.SignHash)

	validatorDporEngine4 := dpor.NewPbftFaker(dporConfig, validatorDb4)
	validatorDporEngine4.Authorize(validatorFakeKeyStore4.addr, validatorFakeKeyStore4.SignHash)

	proposerDporFakeEngine := dpor.NewFaker(dporConfig, proposerDb)
	validatorDporFakeEngine1 := dpor.NewFaker(dporConfig, validatorDb1)
	validatorDporFakeEngine2 := dpor.NewFaker(dporConfig, validatorDb2)
	validatorDporFakeEngine3 := dpor.NewFaker(dporConfig, validatorDb3)
	validatorDporFakeEngine4 := dpor.NewFaker(dporConfig, validatorDb4)

	fsm1 := backend.New(1, 0, validatorDporEngine1)
	fsm2 := backend.New(1, 0, validatorDporEngine2)
	fsm3 := backend.New(1, 0, validatorDporEngine3)
	fsm4 := backend.New(1, 0, validatorDporEngine4)

	_, _, _ = fsm2, fsm3, fsm4

	proposerChain, _ := core.GenerateChain(config, proposerGenesis, proposerDporFakeEngine, proposerDb, proposerRemoteDb, n, nil)
	proposerBlockchain, _ := core.NewBlockChain(proposerDb, nil, gspec.Config, proposerDporEngine, vm.Config{}, proposerRemoteDb, nil)
	validatorChain1, _ := core.GenerateChain(config, validatorGenesis1, validatorDporFakeEngine1, validatorDb1, proposerRemoteDb, n, nil)
	validatorBlockchain1, _ := core.NewBlockChain(validatorDb1, nil, gspec.Config, validatorDporEngine1, vm.Config{}, validatorRemoteDb1, nil)
	validatorChain2, _ := core.GenerateChain(config, validatorGenesis2, validatorDporFakeEngine2, validatorDb2, proposerRemoteDb, n, nil)
	validatorBlockchain2, _ := core.NewBlockChain(validatorDb2, nil, gspec.Config, validatorDporEngine2, vm.Config{}, validatorRemoteDb2, nil)
	validatorChain3, _ := core.GenerateChain(config, validatorGenesis3, validatorDporFakeEngine3, validatorDb3, proposerRemoteDb, n, nil)
	validatorBlockchain3, _ := core.NewBlockChain(validatorDb3, nil, gspec.Config, validatorDporEngine3, vm.Config{}, validatorRemoteDb3, nil)
	validatorChain4, _ := core.GenerateChain(config, validatorGenesis4, validatorDporFakeEngine4, validatorDb4, proposerRemoteDb, n, nil)
	validatorBlockchain4, _ := core.NewBlockChain(validatorDb4, nil, gspec.Config, validatorDporEngine4, vm.Config{}, validatorRemoteDb4, nil)

	proposerDporEngine.SetChain(proposerBlockchain)
	validatorDporEngine1.SetChain(validatorBlockchain1)
	validatorDporEngine2.SetChain(validatorBlockchain2)
	validatorDporEngine3.SetChain(validatorBlockchain3)
	validatorDporEngine4.SetChain(validatorBlockchain4)

	ac := make(map[uint64][]common.Address)
	ac[0] = []common.Address{proposerAddr1}
	// ac[1] = []common.Address{addr1}
	// fmt.Println(ac[0])
	// dporEngine.SetSnapshotProposer(ac)

	_, _, _, _, _, _, _ = fsm1, proposerChain, proposerBlockchain, validatorChain1, validatorChain2, validatorChain3, validatorChain4

	blk1, blkErr := proposerDporEngine.Seal(proposerBlockchain, proposerChain[0], nil)

	fmt.Println("blkErr:", blkErr)

	// Assign the proposer in blk1
	blk1.RefHeader().Dpor.Proposers = make([]common.Address, 1)
	blk1.RefHeader().Dpor.Proposers[0] = proposerAddr1

	// Assgin the validators in blk1
	blk1.RefHeader().Dpor.Validators = make([]common.Address, 4)
	blk1.RefHeader().Dpor.Validators[0] = validatorAddr1
	blk1.RefHeader().Dpor.Validators[1] = validatorAddr2
	blk1.RefHeader().Dpor.Validators[2] = validatorAddr3
	blk1.RefHeader().Dpor.Validators[3] = validatorAddr4

	// blk1.RefHeader().Dpor.Proposers[1] = proposerAddr1

	// fsm1, fsm2, fsm3, fsm4 are all in idle state, all their prepare and commit counter is 0

	// -----1st test------
	// -------test handle pre-prepare block---------

	// output, act, dtype, msg are four arrays storing the results of each test case
	output := make([]interface{}, caseSize)
	act := make([]backend.Action, caseSize)
	dtype := make([]backend.DataType, caseSize)
	msg := make([]backend.MsgCode, caseSize)
	var err error

	// i refers to the index of case
	i := 0
	input, inputType, inputMsg := blk1, backend.BlockType, backend.PreprepareMsgCode
	output[i], act[i], dtype[i], msg[i], err = fsm1.Fsm(input, inputType, inputMsg)

	// fsm1 is now in pre-prepared state, its prepare counter is 1, commit counter is 0
	// fsm2, fsm3 and fsm4 is in idle state, all their prepare and commit counter is 0

	var expectedOutput interface{}
	expectedOutput = input.Header()
	expectedAct := backend.BroadcastMsgAction
	expectedDtype := backend.HeaderType
	expectedMsg := backend.PrepareMsgCode
	var expectedErr error
	expectedErr = nil

	if !reflect.DeepEqual(expectedOutput, output[i]) {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----2nd test------
	// -------test handle prepare message (not suffice a prepare certificate)---------
	// fsm2.Fsm(input, inputType, msg)
	i = 1
	output[i], act[i], dtype[i], msg[i], err = fsm2.Fsm(output[0], dtype[0], msg[0])

	// fsm1 is now in pre-prepared state, its prepare counter is 1 (signed by fsm1), commit counter is 0
	// fsm2 is now in idle state, its prepare counter is 1 (signed by fsm1). commit counter is 0
	// fsm3 and fsm4 is in idle state, all their prepare and commit counter is 0

	expectedOutput = nil
	expectedAct = backend.NoAction
	expectedDtype = backend.NoType
	expectedMsg = backend.NoMsgCode
	expectedErr = nil

	if !reflect.DeepEqual(expectedOutput, output[i]) && expectedOutput != output[i] {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----3rd test------
	// -------test handle prepare message (handle redundant prepare message from a same validator)---------

	i = 2
	output31, act31, dtype31, msg31, err31 := fsm3.Fsm(input, inputType, inputMsg)
	_, _, _, _, _ = output31, act31, dtype31, msg31, err31
	// _, _, _, _, _ = fsm4.Fsm(output31, dtype31, msg31)
	output32, act32, dtype32, msg32, err32 := fsm4.Fsm(input, inputType, inputMsg)
	_, _, _, _, _ = output32, act32, dtype32, msg32, err32
	_, _, _, _, _ = fsm4.Fsm(output31, dtype31, msg31)
	output[i], act[i], dtype[i], msg[i], err = fsm4.Fsm(output31, dtype31, msg31)

	// fsm1 is now in pre-prepared state, its prepare counter is 1 (signed by fsm1), commit counter is 0
	// fsm2 is now in idle state, its prepare counter is 1 (signed by fsm1). commit counter is 0
	// fsm3 is now in pre-prepared state, its prepare counter is 1 (signed by fsm3), commit counter is 0
	// fsm4 is now in pre-prepared state, its prepare counter is 2 (signed by fsm3, fsm4), commit counter is 0

	expectedOutput = nil
	expectedAct = backend.NoAction
	expectedDtype = backend.NoType
	expectedMsg = backend.NoMsgCode
	expectedErr = nil

	if !reflect.DeepEqual(expectedOutput, output[i]) && expectedOutput != output[i] {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----4th test------
	// -------test handle prepare message (suffice a prepare certificate)---------

	i = 3
	var input4 types.Header // input4 is a deep copy *output[0]
	input4 = *output[0].(*types.Header)
	output[i], act[i], dtype[i], msg[i], err = fsm4.Fsm(&input4, dtype[0], msg[0])
	_, _, _, _, _ = output[i], act[i], dtype[i], msg[i], err

	// fsm1 is now in pre-prepared state, its prepare counter is 1 (signed by fsm1), commit counter is 0
	// fsm2 is now in idle state, its prepare counter is 1 (signed by fsm1). commit counter is 0
	// fsm3 is now in pre-prepared state, its prepare counter is 1 (signed by fsm3), commit counter is 0
	// fsm4 is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4), commit counter is 1 (fsm4)

	// fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output4)

	//fmt.Printf("PrepareSigState:\t%+v\n", *fsm4.PrepareSigState()[validatorAddr4])
	//fmt.Printf("CommitSigState: \t%+v\n", *fsm4.CommitSigState()[validatorAddr4])

	expectedHeader := input.Header()
	//expectedSigs := make([]types.DporSignature, validatorNum)
	//_ = expectedSigs
	//expectedSigItems := fsm4.CommitSigState()[validatorAddr4].Sig()
	//copy(expectedHeader.Dpor.Sigs[3][:], expectedSigItems[:])

	_, sigs, sigErr := fsm4.Service().EcrecoverSigs(expectedHeader, consensus.Prepared)
	if sigErr != nil {
		t.Errorf("error for get sigs, error is %v\n", sigErr)
	}

	copy(expectedHeader.Dpor.Sigs[3][:], sigs[len(sigs)-1][:])
	fmt.Printf("Sigs: %+v\n", sigs)

	expectedOutput = expectedHeader

	expectedAct = backend.BroadcastMsgAction
	expectedDtype = backend.HeaderType
	expectedMsg = backend.CommitMsgCode
	expectedErr = nil

	fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])

	// fmt.Printf("PrepareSigState: %+v\n", *fsm4.PrepareSigState()[validatorAddr4])
	// fmt.Printf("CommitSigState: %+v\n", *fsm4.CommitSigState()[validatorAddr4])

	if !reflect.DeepEqual(expectedOutput, output[i]) && expectedOutput != output[i] {
		t.Errorf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----5th test------
	// -------test handle prepare message (suffice a prepare certificate without receiving pre-prepare message from the proposer)---------

	i = 4
	_, _, _, _, _ = fsm2.Fsm(output31, dtype31, msg31)                            // prepare message from fsm3
	output[i], act[i], dtype[i], msg[i], err = fsm2.Fsm(output32, dtype32, msg32) // prepare message from fsm4
	// prepare message from fsm1 has already been received in 2nd case
	// _ = output[i]
	// fsm1 is now in pre-prepared state, its prepare counter is 1 (signed by fsm1), commit counter is 0
	// fsm2 is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4). commit counter is 1 (fsm2)
	// fsm3 is now in pre-prepared state, its prepare counter is 1 (signed by fsm3), commit counter is 0
	// fsm4 is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4), commit counter is 1 (fsm4)

	expectedOutput = output[0]
	expectedAct = backend.BroadcastMsgAction
	expectedDtype = backend.HeaderType
	expectedMsg = backend.CommitMsgCode
	expectedErr = nil

	expectedHeader = input.Header()
	_, sigs, sigErr = fsm2.Service().EcrecoverSigs(expectedHeader, consensus.Prepared)
	if sigErr != nil {
		t.Errorf("error for get sigs, error is %v\n", sigErr)
	}

	fmt.Printf("sigs:%+v\n", sigs)

	copy(expectedHeader.Dpor.Sigs[3][:], sigs[0][:])

	fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])

	fmt.Printf("PrepareSigState: %+v\n", fsm2.PrepareSigState())
	fmt.Printf("CommitSigState :%+v\n", fsm2.CommitSigState())
	fmt.Printf("PrepareSigState [validatorAddr1]: %+v\n", fsm2.PrepareSigState()[validatorAddr1])
	fmt.Printf("CommitSigState [ValidatorAddr1]:%+v\n", fsm2.CommitSigState()[validatorAddr1])
	fmt.Printf("PrepareSigState [validatorAddr2]: %+v\n", fsm2.PrepareSigState()[validatorAddr2])
	fmt.Printf("CommitSigState [ValidatorAddr2]:%+v\n", fsm2.CommitSigState()[validatorAddr2])
	fmt.Printf("PrepareSigState [validatorAddr3]: %+v\n", fsm2.PrepareSigState()[validatorAddr3])
	fmt.Printf("CommitSigState [ValidatorAddr3]:%+v\n", fsm2.CommitSigState()[validatorAddr3])
	fmt.Printf("PrepareSigState [validatorAddr4]: %+v\n", fsm2.PrepareSigState()[validatorAddr4])
	fmt.Printf("CommitSigState [ValidatorAddr4]:%+v\n", fsm2.CommitSigState()[validatorAddr4])

	//if !reflect.DeepEqual(expectedOutput, output[i]) && expectedOutput != output[i] {
	//	T.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	//}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	//fmt.Println("output", output[i], "action", act[i], "data type", dtype3, "msg code", msg3, "error", err3)
	//fmt.Println("output", output4, "action", act4, "data type", dtype4, "msg code", msg4, "error", err4)

	// -----6th test------
	// -------test handle commit message (not suffice a commit certificate)---------

	i = 5
	var input6 types.Header
	input6 = *output[3].(*types.Header)
	output[i], act[i], dtype[i], msg[i], err = fsm2.Fsm(&input6, dtype[3], msg[3])
	_, _, _, _, _ = output[i], act[i], dtype[i], msg[i], err
	// fmt.Println("output", output6, "action", act6, "data type", dtype6, "msg code", msg6, "error", err6)

	// fsm1 is now in pre-prepared state, its prepare counter is 1 (signed by fsm1), commit counter is 0
	// fsm2 is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4). commit counter is 2 (fsm2, fsm4)
	// fsm3 is now in pre-prepared state, its prepare counter is 1 (signed by fsm3), commit counter is 0
	// fsm4 is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4), commit counter is 1 (fsm4)

	expectedOutput = nil
	expectedAct = backend.NoAction
	expectedDtype = backend.NoType
	expectedMsg = backend.NoMsgCode
	expectedErr = nil

	if !reflect.DeepEqual(expectedOutput, output[i]) && expectedOutput != output[i] {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----7th test------
	// -------test handle commit message (handle redundant prepare message from a same validator)---------

	// Let fsm2 receive a redundant commit message from fsm4
	i = 6
	output[i], act[i], dtype[i], msg[i], err = fsm2.Fsm(&input6, dtype[3], msg[3])
	_, _, _, _, _ = output[i], act[i], dtype[i], msg[i], err

	expectedOutput = nil
	expectedAct = backend.NoAction
	expectedDtype = backend.NoType
	expectedMsg = backend.NoMsgCode
	expectedErr = nil

	// fsm1 is now in pre-prepared state, its prepare counter is 1 (signed by fsm1), commit counter is 0
	// fsm2 is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4). commit counter is 2 (fsm2, fsm4)
	// fsm3 is now in pre-prepared state, its prepare counter is 1 (signed by fsm3), commit counter is 0
	// fsm4 is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4), commit counter is 1 (fsm4)

	if !reflect.DeepEqual(expectedOutput, output[i]) && expectedOutput != output[i] {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----8th test------
	// -------test handle commit message (suffice a commit certificate)---------

	// Let fsm1 proceed to prepared state
	i = 7
	fsm1.Fsm(output31, dtype31, msg31)
	output81, act81, dtype81, msg81, err81 := fsm1.Fsm(output32, dtype32, msg32)
	_, _, _, _, _ = output81, act81, dtype81, msg81, err81
	fmt.Println("output", output81, "action", act81, "data type", dtype81, "msg code", msg81, "error", err81)

	// Let fsm2 receive the commit message from fsm1
	var input8 types.Header
	input8 = *output81.(*types.Header)

	// Let fsm2 receive the proposed block; otherwise it cannot generate a validate message
	fsm2.Fsm(input, inputType, inputMsg)
	output[i], act[i], dtype[i], msg[i], err = fsm2.Fsm(&input8, dtype81, msg81)

	// Let the older block number = 1, the newer block number = 2
	// fsm1 (#blk = 1) is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4), commit counter is 1 (fsm1)
	// fsm2 (#blk = 2) is now in idle state, its prepare counter of (#blk = 1) is 3 (signed by fsm1, fsm3, fsm4). commit counter is 3 (fsm2, fsm4 ,fsm1)
	// fsm3 (#blk = 1) is now in pre-prepared state, its prepare counter is 1 (signed by fsm3), commit counter is 0
	// fsm4 (#blk = 1) is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4), commit counter is 1 (fsm4)

	expectedOutput = input
	expectedAct = backend.BroadcastAndInsertBlockAction
	expectedDtype = backend.BlockType
	expectedMsg = backend.ValidateMsgCode
	expectedErr = nil

	// TODO: composeValidateMsg failed since fsm2 cannot retrieve block from cache
	fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])
	// fmt.Println("output", output[i], "action", act[i], "data type", dtype[i], "msg code", msg[i], "error", err)

	if !reflect.DeepEqual(expectedOutput, output[i]) && expectedOutput != output[i] {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----9th test------
	// -------test handle commit message (suffice a commit certificate from idle state)---------

	// -----10th test------
	// -------test handle commit message (suffice a commit certificate from pre-prepared state)---------

	// -----11th test------
	// -------test handle validate message (receive in idle state)---------

	// -----12th test------
	// -------test handle validate message (pre-prepared state)---------

	i = 11
	output[i], act[i], dtype[i], msg[i], err = fsm3.Fsm(output[7], dtype[7], msg[7])
	// fmt.Println("output", output[i], "action", act[i], "data type", dtype[i], "msg code", msg[i], "error", err)

	// fsm1 (#blk = 1) is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4), commit counter is 1 (fsm1)
	// fsm2 (#blk = 2) is now in idle state, its prepare counter of (#blk = 1) is 3 (signed by fsm1, fsm3, fsm4). commit counter is 3 (fsm2, fsm4 ,fsm1)
	// fsm3 (#blk = 2) is now in idle state, its prepare counter of (#blk = 2) is 0, commit counter is 0
	// fsm4 (#blk = 1) is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4), commit counter is 1 (fsm4)

	expectedOutput = input
	expectedAct = backend.InsertBlockAction
	expectedDtype = backend.BlockType
	expectedMsg = backend.NoMsgCode
	expectedErr = nil

	if !reflect.DeepEqual(expectedOutput, output[i]) && expectedOutput != output[i] {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----13th test------
	// -------test handle validate message (prepared state)---------

	i = 12
	output[i], act[i], dtype[i], msg[i], err = fsm1.Fsm(output[7], dtype[7], msg[7])
	// fmt.Println("output", output[i], "action", act[i], "data type", dtype[i], "msg code", msg[i], "error", err)

	// fsm1 (#blk = 2) is now in idle state, its prepare counter of (#blk = 2) is 0, commit counter is 0
	// fsm2 (#blk = 2) is now in idle state, its prepare counter of (#blk = 1) is 3 (signed by fsm1, fsm3, fsm4). commit counter is 3 (fsm2, fsm4 ,fsm1)
	// fsm3 (#blk = 2) is now in idle state, its prepare counter of (#blk = 2) is 0, commit counter is 0
	// fsm4 (#blk = 1) is now in prepared state, its prepare counter is 3 (signed by fsm1, fsm3, fsm4), commit counter is 1 (fsm4)

	expectedOutput = input
	expectedAct = backend.InsertBlockAction
	expectedDtype = backend.BlockType
	expectedMsg = backend.NoMsgCode
	expectedErr = nil

	if !reflect.DeepEqual(expectedOutput, output[i]) && expectedOutput != output[i] {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

}

// This function is to test DporStateMachine.Fsm with regarding to the impeachment process
func TestDporStateMachine_FsmImpeach(t *testing.T) {

	// t.Skip("Skip since it has not finished yet")

	// About to create an emulated chain for testing

	// n refers the number of fake blocks generated by fate engine
	n := 5

	// The 2nd signer is the first proposer
	proposerAddr1, proposerKey1 := loadDefaultAccount(4)
	validatorAddr1, validatorKey1 := loadDefaultAccount(9)
	validatorAddr2, validatorKey2 := loadDefaultAccount(10)
	validatorAddr3, validatorKey3 := loadDefaultAccount(11)
	validatorAddr4, validatorKey4 := loadDefaultAccount(1)

	//_, _ = validatorAddr1, validatorKey1

	for i := 7; i <= 10; i++ {
		j := i
		if i == 10 {
			j = 1
		}
		addrTemp, _ := loadDefaultAccount(j)
		fmt.Println(i, "addr:", addrTemp)
	}
	proposerFakeKeyStore := newFakeKeyStore(proposerAddr1, proposerKey1)
	validatorFakeKeyStore1 := newFakeKeyStore(validatorAddr1, validatorKey1)
	validatorFakeKeyStore2 := newFakeKeyStore(validatorAddr2, validatorKey2)
	validatorFakeKeyStore3 := newFakeKeyStore(validatorAddr3, validatorKey3)
	validatorFakeKeyStore4 := newFakeKeyStore(validatorAddr4, validatorKey4)

	proposerDb := database.NewMemDatabase()
	proposerRemoteDb := database.NewIpfsDbWithAdapter(database.NewFakeIpfsAdapter())
	validatorRemoteDb1 := database.NewIpfsDbWithAdapter(database.NewFakeIpfsAdapter())
	validatorRemoteDb2 := database.NewIpfsDbWithAdapter(database.NewFakeIpfsAdapter())
	validatorRemoteDb3 := database.NewIpfsDbWithAdapter(database.NewFakeIpfsAdapter())
	validatorRemoteDb4 := database.NewIpfsDbWithAdapter(database.NewFakeIpfsAdapter())

	validatorDb1 := database.NewMemDatabase()
	validatorDb2 := database.NewMemDatabase()
	validatorDb3 := database.NewMemDatabase()
	validatorDb4 := database.NewMemDatabase()

	gspec := core.DefaultGenesisBlock()
	gspec.Alloc = core.GenesisAlloc{
		proposerAddr1: {Balance: big.NewInt(1000000000000)},
	}
	proposerGenesis := gspec.MustCommit(proposerDb)
	validatorGenesis1 := gspec.MustCommit(validatorDb1)
	validatorGenesis2 := gspec.MustCommit(validatorDb2)
	validatorGenesis3 := gspec.MustCommit(validatorDb3)
	validatorGenesis4 := gspec.MustCommit(validatorDb4)

	config := gspec.Config
	dporConfig := config.Dpor

	// dpor.NewPbftFaker() create a dpor Engine in which circumvents verifying the legality of proposer
	// TODO: @shiyc a better testing should avoid adopting NewPbftFaker method
	proposerDporEngine := dpor.NewPbftFaker(dporConfig, proposerDb)
	proposerDporEngine.Authorize(proposerFakeKeyStore.addr, proposerFakeKeyStore.SignHash)

	validatorDporEngine1 := dpor.NewPbftFaker(dporConfig, validatorDb1)
	validatorDporEngine1.Authorize(validatorFakeKeyStore1.addr, validatorFakeKeyStore1.SignHash)

	validatorDporEngine2 := dpor.NewPbftFaker(dporConfig, validatorDb2)
	validatorDporEngine2.Authorize(validatorFakeKeyStore2.addr, validatorFakeKeyStore2.SignHash)

	validatorDporEngine3 := dpor.NewPbftFaker(dporConfig, validatorDb3)
	validatorDporEngine3.Authorize(validatorFakeKeyStore3.addr, validatorFakeKeyStore3.SignHash)

	validatorDporEngine4 := dpor.NewPbftFaker(dporConfig, validatorDb4)
	validatorDporEngine4.Authorize(validatorFakeKeyStore4.addr, validatorFakeKeyStore4.SignHash)

	proposerDporFakeEngine := dpor.NewFaker(dporConfig, proposerDb)
	validatorDporFakeEngine1 := dpor.NewFaker(dporConfig, validatorDb1)
	validatorDporFakeEngine2 := dpor.NewFaker(dporConfig, validatorDb2)
	validatorDporFakeEngine3 := dpor.NewFaker(dporConfig, validatorDb3)
	validatorDporFakeEngine4 := dpor.NewFaker(dporConfig, validatorDb4)

	fsm1 := backend.New(1, 0, validatorDporEngine1)
	fsm2 := backend.New(1, 0, validatorDporEngine2)
	fsm3 := backend.New(1, 0, validatorDporEngine3)
	fsm4 := backend.New(1, 0, validatorDporEngine4)

	_, _, _ = fsm2, fsm3, fsm4

	proposerChain, _ := core.GenerateChain(config, proposerGenesis, proposerDporFakeEngine, proposerDb, proposerRemoteDb, n, nil)
	proposerBlockchain, _ := core.NewBlockChain(proposerDb, nil, gspec.Config, proposerDporEngine, vm.Config{}, proposerRemoteDb, nil)
	validatorChain1, _ := core.GenerateChain(config, validatorGenesis1, validatorDporFakeEngine1, validatorDb1, proposerRemoteDb, n, nil)
	validatorBlockchain1, _ := core.NewBlockChain(validatorDb1, nil, gspec.Config, validatorDporEngine1, vm.Config{}, validatorRemoteDb1, nil)
	validatorChain2, _ := core.GenerateChain(config, validatorGenesis2, validatorDporFakeEngine2, validatorDb2, proposerRemoteDb, n, nil)
	validatorBlockchain2, _ := core.NewBlockChain(validatorDb2, nil, gspec.Config, validatorDporEngine2, vm.Config{}, validatorRemoteDb2, nil)
	validatorChain3, _ := core.GenerateChain(config, validatorGenesis3, validatorDporFakeEngine3, validatorDb3, proposerRemoteDb, n, nil)
	validatorBlockchain3, _ := core.NewBlockChain(validatorDb3, nil, gspec.Config, validatorDporEngine3, vm.Config{}, validatorRemoteDb3, nil)
	validatorChain4, _ := core.GenerateChain(config, validatorGenesis4, validatorDporFakeEngine4, validatorDb4, proposerRemoteDb, n, nil)
	validatorBlockchain4, _ := core.NewBlockChain(validatorDb4, nil, gspec.Config, validatorDporEngine4, vm.Config{}, validatorRemoteDb4, nil)

	proposerDporEngine.SetChain(proposerBlockchain)
	validatorDporEngine1.SetChain(validatorBlockchain1)
	validatorDporEngine2.SetChain(validatorBlockchain2)
	validatorDporEngine3.SetChain(validatorBlockchain3)
	validatorDporEngine4.SetChain(validatorBlockchain4)

	ac := make(map[uint64][]common.Address)
	ac[0] = []common.Address{proposerAddr1}
	// ac[1] = []common.Address{addr1}
	// fmt.Println(ac[0])
	// dporEngine.SetSnapshotProposer(ac)

	_, _, _, _, _, _, _ = fsm1, proposerChain, proposerBlockchain, validatorChain1, validatorChain2, validatorChain3, validatorChain4

	blk1, _ := proposerDporEngine.Seal(proposerBlockchain, proposerChain[0], nil)

	fmt.Printf("blk1.header(): %+v", blk1.Header())

	// Assign the proposer in blk1
	blk1.RefHeader().Dpor.Proposers = make([]common.Address, 1)
	blk1.RefHeader().Dpor.Proposers[0] = proposerAddr1

	// Assign the validators in blk1
	blk1.RefHeader().Dpor.Validators = make([]common.Address, 4)
	blk1.RefHeader().Dpor.Validators[0] = validatorAddr1
	blk1.RefHeader().Dpor.Validators[1] = validatorAddr2
	blk1.RefHeader().Dpor.Validators[2] = validatorAddr3
	blk1.RefHeader().Dpor.Validators[3] = validatorAddr4

	// -----1st test------
	// -------propose an impeach block in idle state---------

	output := make([]interface{}, caseSize)
	act := make([]backend.Action, caseSize)
	dtype := make([]backend.DataType, caseSize)
	msg := make([]backend.MsgCode, caseSize)
	var err error

	i := 0
	var input interface{}

	input, inputType, inputMsg := nil, backend.NoType, backend.ImpeachPreprepareMsgCode
	output[i], act[i], dtype[i], msg[i], err = fsm1.Fsm(input, inputType, inputMsg)

	// fsm1 is now in impeach pre-prepared state, its prepare counter is 1 (fsm1), commit counter is 0
	// fsm2, fsm3 and fsm4 is in idle state, all their prepare and commit counter is 0

	var expectedOutput interface{}
	expectedHeader := output[i].(*types.Header)
	expectedOutput = expectedHeader
	expectedAct := backend.BroadcastMsgAction
	expectedDtype := backend.HeaderType
	expectedMsg := backend.ImpeachPrepareMsgCode
	var expectedErr error
	expectedErr = nil

	// TODO: impeach block does not have sigs, proposes and validators, which is incorrect.
	fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i].(*types.Header))

	if !reflect.DeepEqual(expectedOutput, output[i]) {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----2nd test------
	// -------propose an impeach block in pre-prepared state---------

	// let fsm2 enter pre-prepare state by receiving blk1
	i = 1
	input2, inputType2, inputMsg2 := blk1, backend.BlockType, backend.PreprepareMsgCode
	_, _, _ = input2, inputType2, inputMsg2
	// fsm2.Fsm(input2, inputType2, inputMsg2)

	// And then fsm2 receives an impeach pre-prepare message.
	output[i], act[i], dtype[i], msg[i], err = fsm2.Fsm(input, inputType, inputMsg)

	// fsm1 is now in impeach pre-prepared state, its prepare counter is 1 (fsm1), commit counter is 0
	// fsm2 is now in impeach pre-prepared state, its prepare counter is 1 (fsm2), commit counter is 0
	// fsm3 and fsm4 is in idle state, all their prepare and commit counter is 0

	expectedHeader = output[i].(*types.Header)
	expectedOutput = expectedHeader
	expectedAct = backend.BroadcastMsgAction
	expectedDtype = backend.HeaderType
	expectedMsg = backend.ImpeachPrepareMsgCode
	expectedErr = nil

	fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])

	if !reflect.DeepEqual(expectedOutput, output[i]) {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----3th test------
	// -------handle impeach prepare message (idle state, do not suffice an impeach prepare certificate)---------

	i = 2
	output[i], act[i], dtype[i], msg[i], err = fsm3.Fsm(output[0], dtype[0], msg[0])

	// fsm1 is now in impeach pre-prepared state, its prepare counter is 1 (fsm1), commit counter is 0
	// fsm2 is now in impeach pre-prepared state, its prepare counter is 1 (fsm2), commit counter is 0
	// fsm3 is in idle state, its impeach prepare counter is 1 (fsm1), commit counter is 0
	// fsm4 is in idle state, both its prepare and commit counter is 0

	// fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])
	// fmt.Println("dtype:", dtype[i], "msg:", msg[i])

	expectedOutput = nil
	expectedAct = backend.NoAction
	expectedDtype = backend.NoType
	expectedMsg = backend.NoMsgCode
	expectedErr = nil

	fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])

	if !reflect.DeepEqual(expectedOutput, output[i]) {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----4th test------
	// -------handle impeach prepare message (idle state, receive redundant impeach prepare messages)---------

	i = 3
	// fsm3 receive a redundant impeach prepare message from fsm1, and one from fsm2
	fsm3.Fsm(output[0], dtype[0], msg[0])
	output[i], act[i], dtype[i], msg[i], err = fsm3.Fsm(output[1], dtype[1], msg[1])

	// fsm1 is now in impeach pre-prepared state, its prepare counter is 1 (fsm1), commit counter is 0
	// fsm2 is now in impeach pre-prepared state, its prepare counter is 1 (fsm2), commit counter is 0
	// fsm3 is in idle state, its impeach prepare counter is 2 (fsm1, fsm2), commit counter is 0
	// fsm4 is in idle state, both its prepare and commit counter is 0

	// fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])
	// fmt.Println("dtype:", dtype[i], "msg:", msg[i])

	expectedOutput = nil
	expectedAct = backend.NoAction
	expectedDtype = backend.NoType
	expectedMsg = backend.NoMsgCode
	expectedErr = nil

	fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])

	if !reflect.DeepEqual(expectedOutput, output[i]) {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----5th test------
	// -------handle impeach prepare message (idle state, suffice an impeach prepare certificate)--------

	i = 4
	// the timer of fsm expires, it receives an impeach pre-prepare message
	var output4 []interface{}
	output4, act[i], dtype[i], msg[i], err = fsm3.FSM(input, inputType, inputMsg)
	output[4] = output4[0]

	// fsm1 is now in impeach pre-prepared state, its prepare counter is 1 (fsm1), commit counter is 0
	// fsm2 is now in impeach pre-prepared state, its prepare counter is 1 (fsm2), commit counter is 0
	// fsm3 is now in impeach prepared state, its impeach prepare counter is 3 (fsm1, fsm2, fsm3), commit counter is 1 (fsm3)
	// fsm4 is in idle state, both its prepare and commit counter is 0

	fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])
	fmt.Println("dtype:", dtype[i], "msg:", msg[i])

	expectedHeader = output[i].(*types.Header)

	_, sigs, sigErr := fsm3.Service().EcrecoverSigs(expectedHeader, consensus.ImpeachPreprepared)
	if sigErr != nil {
		t.Errorf("error for get sigs, error is %v\n", sigErr)
	}

	fmt.Printf("Sigs: %+v\n", sigs)
	copy(expectedHeader.Dpor.Sigs[2][:], sigs[len(sigs)-1][:])

	expectedOutput = expectedHeader
	expectedAct = backend.BroadcastMultipleMsgAction
	expectedDtype = backend.HeaderType
	expectedMsg = backend.ImpeachPrepareAndCommitMsgCode
	expectedErr = nil

	fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])

	if !reflect.DeepEqual(expectedOutput, output[i]) {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----6th test------
	// -------handle impeach prepare message (impeach pre-prepared state)---------

	i = 5
	fmt.Println("i = ", i)

	// Here we use backend.ImpeachPrepareMsgCode instead of msg[4],
	// since msg[4] includes two message.
	fsm1.Fsm(output[4], dtype[4], backend.ImpeachPrepareMsgCode)
	output[i], act[i], dtype[i], msg[i], err = fsm1.Fsm(output[1], dtype[1], msg[1])

	//fmt.Println("haha")
	//fsm4.Fsm(output[4], dtype[4], backend.ImpeachPrepareMsgCode)
	//fmt.Println("hehe")
	//fsm2.Fsm(output[4], dtype[4], backend.ImpeachPrepareMsgCode)

	// fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])

	// fsm1 is now in impeach prepared state, its impeach prepare counter is 3 (fsm1, fsm2, fsm3), commit counter is 1 (fsm1)
	// fsm2 is now in impeach pre-prepared state, its prepare counter is 1 (fsm2), commit counter is 0
	// fsm3 is now in impeach prepared state, its impeach prepare counter is 3 (fsm1, fsm2, fsm3), commit counter is 1 (fsm3)
	// fsm4 is in idle state, both its prepare and commit counter is 0

	expectedHeader = output[i].(*types.Header)

	_, sigs, sigErr = fsm1.Service().EcrecoverSigs(expectedHeader, consensus.ImpeachPreprepared)
	if sigErr != nil {
		t.Errorf("error for get sigs, error is %v\n", sigErr)
	}

	fmt.Printf("Sigs: %+v\n", sigs)
	copy(expectedHeader.Dpor.Sigs[2][:], sigs[len(sigs)-1][:])

	expectedOutput = expectedHeader
	expectedAct = backend.BroadcastMsgAction
	expectedDtype = backend.HeaderType
	expectedMsg = backend.ImpeachCommitMsgCode
	expectedErr = nil

	if !reflect.DeepEqual(expectedOutput, output[i]) {
		t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	}
	if expectedAct != act[i] {
		t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	}
	if expectedDtype != dtype[i] {
		t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	}
	if expectedMsg != msg[i] {
		t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	}
	if expectedErr != err {
		t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	}

	// -----7th test------
	// -------handle impeach prepare message (idle state) without receiving impeach pre-prepare message---------

	// Let fsm4 (idle state) receive impeach prepare message from fsm1, fsm2 and fsm3
	i = 6
	// fsm4.Fsm(output[0], dtype[0], msg[0])
	// fsm4.Fsm(output[1], dtype[1], msg[1])
	output[i], act[i], dtype[i], msg[i], err = fsm4.Fsm(output4[1], dtype[4], backend.ImpeachPrepareMsgCode)
	fsm4.Fsm(output[1], dtype[1], msg[1])
	fsm4.Fsm(output[0], dtype[0], msg[0])
	fmt.Printf("the expected output is \n %+v, got \n %+v\n", expectedOutput, output[i])
	// TODO: an bug here that fsm4 cannot accumulate an impeach prepare counter to 3.
	// fsm1 is now in impeach prepared state, its impeach prepare counter is 3 (fsm1, fsm2, fsm3), commit counter is 1 (fsm1)
	// fsm2 is now in impeach pre-prepared state, its prepare counter is 1 (fsm2), commit counter is 0
	// fsm3 is now in impeach prepared state, its impeach prepare counter is 3 (fsm1, fsm2, fsm3), commit counter is 1 (fsm3)
	// fsm4 is now in impeach prepared state, its impeach prepare counter is 3 (fsm1, fsm2, fsm3), commit counter is 1 (fsm4)

	//expectedHeader = output[i].(*types.Header)
	//
	//_, sigs, sigErr = fsm4.Service().EcrecoverSigs(expectedHeader, consensus.ImpeachPreprepared)
	//if sigErr != nil {
	//	t.Errorf("error for get sigs, error is %v\n", sigErr)
	//}
	//
	//fmt.Printf("Sigs: %+v\n", sigs)
	//copy(expectedHeader.Dpor.Sigs[2][:], sigs[len(sigs)-1][:])
	//
	//expectedOutput = expectedHeader
	//expectedAct = backend.BroadcastMsgAction
	//expectedDtype = backend.HeaderType
	//expectedMsg = backend.ImpeachCommitMsgCode
	//expectedErr = nil
	//
	//if !reflect.DeepEqual(expectedOutput, output[i]) {
	//	t.Errorf("the expected output is \n %v, got \n %v\n", expectedOutput, output[i])
	//}
	//if expectedAct != act[i] {
	//	t.Errorf("the expected action is \n %v, got \n %v\n", expectedAct, act[i])
	//}
	//if expectedDtype != dtype[i] {
	//	t.Errorf("the expected data type is \n %v, got \n %v\n", expectedDtype, dtype[i])
	//}
	//if expectedMsg != msg[i] {
	//	t.Errorf("the expected message is \n %v, got \n %v\n", expectedMsg, msg[i])
	//}
	//if expectedErr != err {
	//	t.Errorf("the expected error is \n %v, got \n %v\n", expectedErr, err)
	//}

	// -----20th test------
	// -------handle impeach commit message (pre-prepared state)---------

	// -----21st test------
	// -------handle impeach commit message (prepared state)---------

	// -----22nd test------
	// -------handle impeach commit message (impeach pre-prepared state)---------

	// -----20th test------
	// -------handle impeach commit message (prepared state)---------

	// -----21th test------
	// -------handle impeach validate message (idle state)---------
}

type fakeKeystore struct {
	addr common.Address
	key  *keystore.Key
}

func newFakeKeyStore(addr common.Address, key *keystore.Key) *fakeKeystore {
	return &fakeKeystore{
		addr: addr,
		key:  key,
	}
}

func (fk *fakeKeystore) SignHash(account accounts.Account, hash []byte) ([]byte, error) {
	if account.Address == fk.addr {
		return crypto.Sign(hash, fk.key.PrivateKey)
	}
	return nil, errors.New("wrong account")
}
