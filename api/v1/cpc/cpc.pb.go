// Code generated by protoc-gen-go. DO NOT EDIT.
// source: v1/cpc/cpc.proto

package cpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "bitbucket.org/cpchain/chain/api/v1/common"
import empty "github.com/golang/protobuf/ptypes/empty"
import wrappers "github.com/golang/protobuf/ptypes/wrappers"
import _ "google.golang.org/genproto/googleapis/api/annotations"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Works a work package for external miner. The work package consists of 3 strings
// result[0], 32 bytes hex encoded current block header pow-hash
// result[1], 32 bytes hex encoded seed hash used for DAG
// result[2], 32 bytes hex encoded boundary condition ("target"), 2^256/difficulty
type Works struct {
	Works                map[int32]string `protobuf:"bytes,1,rep,name=works,proto3" json:"works,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Works) Reset()         { *m = Works{} }
func (m *Works) String() string { return proto.CompactTextString(m) }
func (*Works) ProtoMessage()    {}
func (*Works) Descriptor() ([]byte, []int) {
	return fileDescriptor_cpc_75fcbb1ca4015d93, []int{0}
}
func (m *Works) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Works.Unmarshal(m, b)
}
func (m *Works) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Works.Marshal(b, m, deterministic)
}
func (dst *Works) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Works.Merge(dst, src)
}
func (m *Works) XXX_Size() int {
	return xxx_messageInfo_Works.Size(m)
}
func (m *Works) XXX_DiscardUnknown() {
	xxx_messageInfo_Works.DiscardUnknown(m)
}

var xxx_messageInfo_Works proto.InternalMessageInfo

func (m *Works) GetWorks() map[int32]string {
	if m != nil {
		return m.Works
	}
	return nil
}

// ChainReaderRequest ChainReader request arguments
type ChainReaderRequest struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	BlockHash            string   `protobuf:"bytes,2,opt,name=blockHash,proto3" json:"blockHash,omitempty"`
	BlockNumber          int64    `protobuf:"varint,3,opt,name=blockNumber,proto3" json:"blockNumber,omitempty"`
	IsFull               bool     `protobuf:"varint,4,opt,name=isFull,proto3" json:"isFull,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChainReaderRequest) Reset()         { *m = ChainReaderRequest{} }
func (m *ChainReaderRequest) String() string { return proto.CompactTextString(m) }
func (*ChainReaderRequest) ProtoMessage()    {}
func (*ChainReaderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cpc_75fcbb1ca4015d93, []int{1}
}
func (m *ChainReaderRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChainReaderRequest.Unmarshal(m, b)
}
func (m *ChainReaderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChainReaderRequest.Marshal(b, m, deterministic)
}
func (dst *ChainReaderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainReaderRequest.Merge(dst, src)
}
func (m *ChainReaderRequest) XXX_Size() int {
	return xxx_messageInfo_ChainReaderRequest.Size(m)
}
func (m *ChainReaderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainReaderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChainReaderRequest proto.InternalMessageInfo

func (m *ChainReaderRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ChainReaderRequest) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *ChainReaderRequest) GetBlockNumber() int64 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *ChainReaderRequest) GetIsFull() bool {
	if m != nil {
		return m.IsFull
	}
	return false
}

// TransactionCount transaction count
type TransactionCount struct {
	TransactionCount     uint64   `protobuf:"varint,1,opt,name=transactionCount,proto3" json:"transactionCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionCount) Reset()         { *m = TransactionCount{} }
func (m *TransactionCount) String() string { return proto.CompactTextString(m) }
func (*TransactionCount) ProtoMessage()    {}
func (*TransactionCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_cpc_75fcbb1ca4015d93, []int{2}
}
func (m *TransactionCount) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionCount.Unmarshal(m, b)
}
func (m *TransactionCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionCount.Marshal(b, m, deterministic)
}
func (dst *TransactionCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionCount.Merge(dst, src)
}
func (m *TransactionCount) XXX_Size() int {
	return xxx_messageInfo_TransactionCount.Size(m)
}
func (m *TransactionCount) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionCount.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionCount proto.InternalMessageInfo

func (m *TransactionCount) GetTransactionCount() uint64 {
	if m != nil {
		return m.TransactionCount
	}
	return 0
}

// TransactionPoolReaderRequest request parameters
type TransactionPoolReaderRequest struct {
	BlockNumber          uint64   `protobuf:"varint,1,opt,name=blockNumber,proto3" json:"blockNumber,omitempty"`
	Index                uint64   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	BlockHash            string   `protobuf:"bytes,3,opt,name=blockHash,proto3" json:"blockHash,omitempty"`
	Address              string   `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionPoolReaderRequest) Reset()         { *m = TransactionPoolReaderRequest{} }
func (m *TransactionPoolReaderRequest) String() string { return proto.CompactTextString(m) }
func (*TransactionPoolReaderRequest) ProtoMessage()    {}
func (*TransactionPoolReaderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cpc_75fcbb1ca4015d93, []int{3}
}
func (m *TransactionPoolReaderRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionPoolReaderRequest.Unmarshal(m, b)
}
func (m *TransactionPoolReaderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionPoolReaderRequest.Marshal(b, m, deterministic)
}
func (dst *TransactionPoolReaderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionPoolReaderRequest.Merge(dst, src)
}
func (m *TransactionPoolReaderRequest) XXX_Size() int {
	return xxx_messageInfo_TransactionPoolReaderRequest.Size(m)
}
func (m *TransactionPoolReaderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionPoolReaderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionPoolReaderRequest proto.InternalMessageInfo

func (m *TransactionPoolReaderRequest) GetBlockNumber() uint64 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *TransactionPoolReaderRequest) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *TransactionPoolReaderRequest) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *TransactionPoolReaderRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

// RawTransaction transaction bytes
type RawTransaction struct {
	RawTransaction       []byte   `protobuf:"bytes,1,opt,name=rawTransaction,proto3" json:"rawTransaction,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawTransaction) Reset()         { *m = RawTransaction{} }
func (m *RawTransaction) String() string { return proto.CompactTextString(m) }
func (*RawTransaction) ProtoMessage()    {}
func (*RawTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_cpc_75fcbb1ca4015d93, []int{4}
}
func (m *RawTransaction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RawTransaction.Unmarshal(m, b)
}
func (m *RawTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RawTransaction.Marshal(b, m, deterministic)
}
func (dst *RawTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawTransaction.Merge(dst, src)
}
func (m *RawTransaction) XXX_Size() int {
	return xxx_messageInfo_RawTransaction.Size(m)
}
func (m *RawTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_RawTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_RawTransaction proto.InternalMessageInfo

func (m *RawTransaction) GetRawTransaction() []byte {
	if m != nil {
		return m.RawTransaction
	}
	return nil
}

// TransactionHash transaction hash
type TransactionHash struct {
	TransactionHash      string   `protobuf:"bytes,1,opt,name=transactionHash,proto3" json:"transactionHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionHash) Reset()         { *m = TransactionHash{} }
func (m *TransactionHash) String() string { return proto.CompactTextString(m) }
func (*TransactionHash) ProtoMessage()    {}
func (*TransactionHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_cpc_75fcbb1ca4015d93, []int{5}
}
func (m *TransactionHash) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionHash.Unmarshal(m, b)
}
func (m *TransactionHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionHash.Marshal(b, m, deterministic)
}
func (dst *TransactionHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionHash.Merge(dst, src)
}
func (m *TransactionHash) XXX_Size() int {
	return xxx_messageInfo_TransactionHash.Size(m)
}
func (m *TransactionHash) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionHash.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionHash proto.InternalMessageInfo

func (m *TransactionHash) GetTransactionHash() string {
	if m != nil {
		return m.TransactionHash
	}
	return ""
}

func init() {
	proto.RegisterType((*Works)(nil), "cpc.Works")
	proto.RegisterMapType((map[int32]string)(nil), "cpc.Works.WorksEntry")
	proto.RegisterType((*ChainReaderRequest)(nil), "cpc.ChainReaderRequest")
	proto.RegisterType((*TransactionCount)(nil), "cpc.TransactionCount")
	proto.RegisterType((*TransactionPoolReaderRequest)(nil), "cpc.TransactionPoolReaderRequest")
	proto.RegisterType((*RawTransaction)(nil), "cpc.RawTransaction")
	proto.RegisterType((*TransactionHash)(nil), "cpc.TransactionHash")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CoinbaseClient is the client API for Coinbase service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CoinbaseClient interface {
	// Coinbase is the address that mining rewards will be send to
	Coinbase(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.Address, error)
}

type coinbaseClient struct {
	cc *grpc.ClientConn
}

func NewCoinbaseClient(cc *grpc.ClientConn) CoinbaseClient {
	return &coinbaseClient{cc}
}

func (c *coinbaseClient) Coinbase(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.Address, error) {
	out := new(common.Address)
	err := c.cc.Invoke(ctx, "/cpc.Coinbase/Coinbase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CoinbaseServer is the server API for Coinbase service.
type CoinbaseServer interface {
	// Coinbase is the address that mining rewards will be send to
	Coinbase(context.Context, *empty.Empty) (*common.Address, error)
}

func RegisterCoinbaseServer(s *grpc.Server, srv CoinbaseServer) {
	s.RegisterService(&_Coinbase_serviceDesc, srv)
}

func _Coinbase_Coinbase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinbaseServer).Coinbase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.Coinbase/Coinbase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinbaseServer).Coinbase(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Coinbase_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cpc.Coinbase",
	HandlerType: (*CoinbaseServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Coinbase",
			Handler:    _Coinbase_Coinbase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/cpc/cpc.proto",
}

// MinerReaderClient is the client API for MinerReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MinerReaderClient interface {
	// Mining returns an indication if this node is currently mining.
	Mining(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.IsOk, error)
	// GetWork returns a work package for external miner. The work package consists of 3 strings
	// result[0], 32 bytes hex encoded current block header pow-hash
	// result[1], 32 bytes hex encoded seed hash used for DAG
	// result[2], 32 bytes hex encoded boundary condition ("target"), 2^256/difficulty
	GetWork(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Works, error)
}

type minerReaderClient struct {
	cc *grpc.ClientConn
}

func NewMinerReaderClient(cc *grpc.ClientConn) MinerReaderClient {
	return &minerReaderClient{cc}
}

func (c *minerReaderClient) Mining(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.IsOk, error) {
	out := new(common.IsOk)
	err := c.cc.Invoke(ctx, "/cpc.MinerReader/Mining", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *minerReaderClient) GetWork(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Works, error) {
	out := new(Works)
	err := c.cc.Invoke(ctx, "/cpc.MinerReader/GetWork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MinerReaderServer is the server API for MinerReader service.
type MinerReaderServer interface {
	// Mining returns an indication if this node is currently mining.
	Mining(context.Context, *empty.Empty) (*common.IsOk, error)
	// GetWork returns a work package for external miner. The work package consists of 3 strings
	// result[0], 32 bytes hex encoded current block header pow-hash
	// result[1], 32 bytes hex encoded seed hash used for DAG
	// result[2], 32 bytes hex encoded boundary condition ("target"), 2^256/difficulty
	GetWork(context.Context, *empty.Empty) (*Works, error)
}

func RegisterMinerReaderServer(s *grpc.Server, srv MinerReaderServer) {
	s.RegisterService(&_MinerReader_serviceDesc, srv)
}

func _MinerReader_Mining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerReaderServer).Mining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.MinerReader/Mining",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerReaderServer).Mining(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MinerReader_GetWork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerReaderServer).GetWork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.MinerReader/GetWork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerReaderServer).GetWork(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _MinerReader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cpc.MinerReader",
	HandlerType: (*MinerReaderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Mining",
			Handler:    _MinerReader_Mining_Handler,
		},
		{
			MethodName: "GetWork",
			Handler:    _MinerReader_GetWork_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/cpc/cpc.proto",
}

// AccountReaderClient is the client API for AccountReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type AccountReaderClient interface {
	// Accounts returns the collection of accounts this node manages
	Accounts(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.Addresses, error)
}

type accountReaderClient struct {
	cc *grpc.ClientConn
}

func NewAccountReaderClient(cc *grpc.ClientConn) AccountReaderClient {
	return &accountReaderClient{cc}
}

func (c *accountReaderClient) Accounts(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.Addresses, error) {
	out := new(common.Addresses)
	err := c.cc.Invoke(ctx, "/cpc.AccountReader/Accounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AccountReaderServer is the server API for AccountReader service.
type AccountReaderServer interface {
	// Accounts returns the collection of accounts this node manages
	Accounts(context.Context, *empty.Empty) (*common.Addresses, error)
}

func RegisterAccountReaderServer(s *grpc.Server, srv AccountReaderServer) {
	s.RegisterService(&_AccountReader_serviceDesc, srv)
}

func _AccountReader_Accounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AccountReaderServer).Accounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.AccountReader/Accounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AccountReaderServer).Accounts(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _AccountReader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cpc.AccountReader",
	HandlerType: (*AccountReaderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Accounts",
			Handler:    _AccountReader_Accounts_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/cpc/cpc.proto",
}

// ChainStateReaderClient is the client API for ChainStateReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ChainStateReaderClient interface {
	// GasPrice returns a suggestion for a gas price.
	GasPrice(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.GasPrice, error)
	// ProtocolVersion returns the current Ethereum protocol version this node supports
	ProtocolVersion(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*wrappers.UInt32Value, error)
	// Syncing returns false in case the node is currently not syncing with the network. It can be up to date or has not
	// yet received the latest block headers from its pears. In case it is synchronizing:
	// - startingBlock: block number this node started to synchronise from
	// - currentBlock:  block number this node is currently importing
	// - highestBlock:  block number of the highest block header this node has received from peers
	// - pulledStates:  number of state entries processed until now
	// - knownStates:   number of known state entries that still need to be pulled
	Syncing(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.SyncingInfo, error)
}

type chainStateReaderClient struct {
	cc *grpc.ClientConn
}

func NewChainStateReaderClient(cc *grpc.ClientConn) ChainStateReaderClient {
	return &chainStateReaderClient{cc}
}

func (c *chainStateReaderClient) GasPrice(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.GasPrice, error) {
	out := new(common.GasPrice)
	err := c.cc.Invoke(ctx, "/cpc.ChainStateReader/GasPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStateReaderClient) ProtocolVersion(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*wrappers.UInt32Value, error) {
	out := new(wrappers.UInt32Value)
	err := c.cc.Invoke(ctx, "/cpc.ChainStateReader/ProtocolVersion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainStateReaderClient) Syncing(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.SyncingInfo, error) {
	out := new(common.SyncingInfo)
	err := c.cc.Invoke(ctx, "/cpc.ChainStateReader/Syncing", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChainStateReaderServer is the server API for ChainStateReader service.
type ChainStateReaderServer interface {
	// GasPrice returns a suggestion for a gas price.
	GasPrice(context.Context, *empty.Empty) (*common.GasPrice, error)
	// ProtocolVersion returns the current Ethereum protocol version this node supports
	ProtocolVersion(context.Context, *empty.Empty) (*wrappers.UInt32Value, error)
	// Syncing returns false in case the node is currently not syncing with the network. It can be up to date or has not
	// yet received the latest block headers from its pears. In case it is synchronizing:
	// - startingBlock: block number this node started to synchronise from
	// - currentBlock:  block number this node is currently importing
	// - highestBlock:  block number of the highest block header this node has received from peers
	// - pulledStates:  number of state entries processed until now
	// - knownStates:   number of known state entries that still need to be pulled
	Syncing(context.Context, *empty.Empty) (*common.SyncingInfo, error)
}

func RegisterChainStateReaderServer(s *grpc.Server, srv ChainStateReaderServer) {
	s.RegisterService(&_ChainStateReader_serviceDesc, srv)
}

func _ChainStateReader_GasPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStateReaderServer).GasPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.ChainStateReader/GasPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStateReaderServer).GasPrice(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStateReader_ProtocolVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStateReaderServer).ProtocolVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.ChainStateReader/ProtocolVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStateReaderServer).ProtocolVersion(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainStateReader_Syncing_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainStateReaderServer).Syncing(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.ChainStateReader/Syncing",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainStateReaderServer).Syncing(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChainStateReader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cpc.ChainStateReader",
	HandlerType: (*ChainStateReaderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GasPrice",
			Handler:    _ChainStateReader_GasPrice_Handler,
		},
		{
			MethodName: "ProtocolVersion",
			Handler:    _ChainStateReader_ProtocolVersion_Handler,
		},
		{
			MethodName: "Syncing",
			Handler:    _ChainStateReader_Syncing_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/cpc/cpc.proto",
}

// ChainReaderClient is the client API for ChainReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ChainReaderClient interface {
	// GetBlockCount returns the block number of the chain head.
	GetBlockCount(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.BlockNumber, error)
	// GetBalance returns the amount of wei for the given address in the state of the
	// given block number. The rpc.LatestBlockNumber and rpc.PendingBlockNumber meta
	// block numbers are also allowed.
	GetBalance(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*common.Balance, error)
	// GetBlockByNumber returns the requested block. When blockNr is -1 the chain head is returned. When fullTx is true all
	// transactions in the block are returned in full detail, otherwise only the transaction hash is returned.
	GetBlockByNumber(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*common.Block, error)
	// GetBlockByHash returns the requested block. When fullTx is true all transactions in the block are returned in full
	// detail, otherwise only the transaction hash is returned.
	GetBlockByHash(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*common.Block, error)
	// GetCode returns the code stored at the given address in the state for the given block number.
	GetCode(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*common.Code, error)
}

type chainReaderClient struct {
	cc *grpc.ClientConn
}

func NewChainReaderClient(cc *grpc.ClientConn) ChainReaderClient {
	return &chainReaderClient{cc}
}

func (c *chainReaderClient) GetBlockCount(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*common.BlockNumber, error) {
	out := new(common.BlockNumber)
	err := c.cc.Invoke(ctx, "/cpc.ChainReader/GetBlockCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainReaderClient) GetBalance(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*common.Balance, error) {
	out := new(common.Balance)
	err := c.cc.Invoke(ctx, "/cpc.ChainReader/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainReaderClient) GetBlockByNumber(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*common.Block, error) {
	out := new(common.Block)
	err := c.cc.Invoke(ctx, "/cpc.ChainReader/GetBlockByNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainReaderClient) GetBlockByHash(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*common.Block, error) {
	out := new(common.Block)
	err := c.cc.Invoke(ctx, "/cpc.ChainReader/GetBlockByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainReaderClient) GetCode(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*common.Code, error) {
	out := new(common.Code)
	err := c.cc.Invoke(ctx, "/cpc.ChainReader/GetCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChainReaderServer is the server API for ChainReader service.
type ChainReaderServer interface {
	// GetBlockCount returns the block number of the chain head.
	GetBlockCount(context.Context, *empty.Empty) (*common.BlockNumber, error)
	// GetBalance returns the amount of wei for the given address in the state of the
	// given block number. The rpc.LatestBlockNumber and rpc.PendingBlockNumber meta
	// block numbers are also allowed.
	GetBalance(context.Context, *ChainReaderRequest) (*common.Balance, error)
	// GetBlockByNumber returns the requested block. When blockNr is -1 the chain head is returned. When fullTx is true all
	// transactions in the block are returned in full detail, otherwise only the transaction hash is returned.
	GetBlockByNumber(context.Context, *ChainReaderRequest) (*common.Block, error)
	// GetBlockByHash returns the requested block. When fullTx is true all transactions in the block are returned in full
	// detail, otherwise only the transaction hash is returned.
	GetBlockByHash(context.Context, *ChainReaderRequest) (*common.Block, error)
	// GetCode returns the code stored at the given address in the state for the given block number.
	GetCode(context.Context, *ChainReaderRequest) (*common.Code, error)
}

func RegisterChainReaderServer(s *grpc.Server, srv ChainReaderServer) {
	s.RegisterService(&_ChainReader_serviceDesc, srv)
}

func _ChainReader_GetBlockCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainReaderServer).GetBlockCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.ChainReader/GetBlockCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainReaderServer).GetBlockCount(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainReader_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainReaderServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.ChainReader/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainReaderServer).GetBalance(ctx, req.(*ChainReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainReader_GetBlockByNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainReaderServer).GetBlockByNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.ChainReader/GetBlockByNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainReaderServer).GetBlockByNumber(ctx, req.(*ChainReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainReader_GetBlockByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainReaderServer).GetBlockByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.ChainReader/GetBlockByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainReaderServer).GetBlockByHash(ctx, req.(*ChainReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainReader_GetCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainReaderServer).GetCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.ChainReader/GetCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainReaderServer).GetCode(ctx, req.(*ChainReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChainReader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cpc.ChainReader",
	HandlerType: (*ChainReaderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlockCount",
			Handler:    _ChainReader_GetBlockCount_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _ChainReader_GetBalance_Handler,
		},
		{
			MethodName: "GetBlockByNumber",
			Handler:    _ChainReader_GetBlockByNumber_Handler,
		},
		{
			MethodName: "GetBlockByHash",
			Handler:    _ChainReader_GetBlockByHash_Handler,
		},
		{
			MethodName: "GetCode",
			Handler:    _ChainReader_GetCode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/cpc/cpc.proto",
}

// TransactionPoolReaderClient is the client API for TransactionPoolReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TransactionPoolReaderClient interface {
	// GetBlockTransactionCountByNumber returns the number of transactions in the block with the given block number.
	GetTransactionCountByBlockNumber(ctx context.Context, in *common.BlockNumber, opts ...grpc.CallOption) (*TransactionCount, error)
	// GetBlockTransactionCountByHash returns the number of transactions in the block with the given hash.
	GetTransactionCountByBlockHash(ctx context.Context, in *common.BlockHash, opts ...grpc.CallOption) (*TransactionCount, error)
	// GetTransactionByBlockNumberAndIndex returns the transaction for the given block number and index.
	GetTransactionByBlockNumberAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*common.RpcTransaction, error)
	// GetTransactionByBlockHashAndIndex returns the transaction for the given block hash and index.
	GetTransactionByBlockHashAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*common.RpcTransaction, error)
	// GetTransactionByHash returns the transaction for the given hash
	GetRawTransactionByBlockNumberAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*RawTransaction, error)
	// GetRawTransactionByBlockHashAndIndex returns the bytes of the transaction for the given block hash and index.
	GetTransactionByHash(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*common.RpcTransaction, error)
	// GetTransactionReceipt returns the transaction receipt for the given transaction hash.
	GetTransactionReceipt(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*common.Receipt, error)
	// GetTransactionCount returns the number of transactions the given address has sent for the given block number
	GetTransactionCount(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*TransactionCount, error)
}

type transactionPoolReaderClient struct {
	cc *grpc.ClientConn
}

func NewTransactionPoolReaderClient(cc *grpc.ClientConn) TransactionPoolReaderClient {
	return &transactionPoolReaderClient{cc}
}

func (c *transactionPoolReaderClient) GetTransactionCountByBlockNumber(ctx context.Context, in *common.BlockNumber, opts ...grpc.CallOption) (*TransactionCount, error) {
	out := new(TransactionCount)
	err := c.cc.Invoke(ctx, "/cpc.TransactionPoolReader/GetTransactionCountByBlockNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionCountByBlockHash(ctx context.Context, in *common.BlockHash, opts ...grpc.CallOption) (*TransactionCount, error) {
	out := new(TransactionCount)
	err := c.cc.Invoke(ctx, "/cpc.TransactionPoolReader/GetTransactionCountByBlockHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionByBlockNumberAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*common.RpcTransaction, error) {
	out := new(common.RpcTransaction)
	err := c.cc.Invoke(ctx, "/cpc.TransactionPoolReader/GetTransactionByBlockNumberAndIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionByBlockHashAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*common.RpcTransaction, error) {
	out := new(common.RpcTransaction)
	err := c.cc.Invoke(ctx, "/cpc.TransactionPoolReader/GetTransactionByBlockHashAndIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetRawTransactionByBlockNumberAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*RawTransaction, error) {
	out := new(RawTransaction)
	err := c.cc.Invoke(ctx, "/cpc.TransactionPoolReader/GetRawTransactionByBlockNumberAndIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionByHash(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*common.RpcTransaction, error) {
	out := new(common.RpcTransaction)
	err := c.cc.Invoke(ctx, "/cpc.TransactionPoolReader/GetTransactionByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionReceipt(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*common.Receipt, error) {
	out := new(common.Receipt)
	err := c.cc.Invoke(ctx, "/cpc.TransactionPoolReader/GetTransactionReceipt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionCount(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*TransactionCount, error) {
	out := new(TransactionCount)
	err := c.cc.Invoke(ctx, "/cpc.TransactionPoolReader/GetTransactionCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TransactionPoolReaderServer is the server API for TransactionPoolReader service.
type TransactionPoolReaderServer interface {
	// GetBlockTransactionCountByNumber returns the number of transactions in the block with the given block number.
	GetTransactionCountByBlockNumber(context.Context, *common.BlockNumber) (*TransactionCount, error)
	// GetBlockTransactionCountByHash returns the number of transactions in the block with the given hash.
	GetTransactionCountByBlockHash(context.Context, *common.BlockHash) (*TransactionCount, error)
	// GetTransactionByBlockNumberAndIndex returns the transaction for the given block number and index.
	GetTransactionByBlockNumberAndIndex(context.Context, *TransactionPoolReaderRequest) (*common.RpcTransaction, error)
	// GetTransactionByBlockHashAndIndex returns the transaction for the given block hash and index.
	GetTransactionByBlockHashAndIndex(context.Context, *TransactionPoolReaderRequest) (*common.RpcTransaction, error)
	// GetTransactionByHash returns the transaction for the given hash
	GetRawTransactionByBlockNumberAndIndex(context.Context, *TransactionPoolReaderRequest) (*RawTransaction, error)
	// GetRawTransactionByBlockHashAndIndex returns the bytes of the transaction for the given block hash and index.
	GetTransactionByHash(context.Context, *TransactionHash) (*common.RpcTransaction, error)
	// GetTransactionReceipt returns the transaction receipt for the given transaction hash.
	GetTransactionReceipt(context.Context, *TransactionHash) (*common.Receipt, error)
	// GetTransactionCount returns the number of transactions the given address has sent for the given block number
	GetTransactionCount(context.Context, *TransactionPoolReaderRequest) (*TransactionCount, error)
}

func RegisterTransactionPoolReaderServer(s *grpc.Server, srv TransactionPoolReaderServer) {
	s.RegisterService(&_TransactionPoolReader_serviceDesc, srv)
}

func _TransactionPoolReader_GetTransactionCountByBlockNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.BlockNumber)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionCountByBlockNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.TransactionPoolReader/GetTransactionCountByBlockNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionCountByBlockNumber(ctx, req.(*common.BlockNumber))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionCountByBlockHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.BlockHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionCountByBlockHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.TransactionPoolReader/GetTransactionCountByBlockHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionCountByBlockHash(ctx, req.(*common.BlockHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionByBlockNumberAndIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionPoolReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionByBlockNumberAndIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.TransactionPoolReader/GetTransactionByBlockNumberAndIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionByBlockNumberAndIndex(ctx, req.(*TransactionPoolReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionByBlockHashAndIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionPoolReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionByBlockHashAndIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.TransactionPoolReader/GetTransactionByBlockHashAndIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionByBlockHashAndIndex(ctx, req.(*TransactionPoolReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetRawTransactionByBlockNumberAndIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionPoolReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetRawTransactionByBlockNumberAndIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.TransactionPoolReader/GetRawTransactionByBlockNumberAndIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetRawTransactionByBlockNumberAndIndex(ctx, req.(*TransactionPoolReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.TransactionPoolReader/GetTransactionByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionByHash(ctx, req.(*TransactionHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.TransactionPoolReader/GetTransactionReceipt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionReceipt(ctx, req.(*TransactionHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionPoolReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/cpc.TransactionPoolReader/GetTransactionCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionCount(ctx, req.(*TransactionPoolReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TransactionPoolReader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "cpc.TransactionPoolReader",
	HandlerType: (*TransactionPoolReaderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTransactionCountByBlockNumber",
			Handler:    _TransactionPoolReader_GetTransactionCountByBlockNumber_Handler,
		},
		{
			MethodName: "GetTransactionCountByBlockHash",
			Handler:    _TransactionPoolReader_GetTransactionCountByBlockHash_Handler,
		},
		{
			MethodName: "GetTransactionByBlockNumberAndIndex",
			Handler:    _TransactionPoolReader_GetTransactionByBlockNumberAndIndex_Handler,
		},
		{
			MethodName: "GetTransactionByBlockHashAndIndex",
			Handler:    _TransactionPoolReader_GetTransactionByBlockHashAndIndex_Handler,
		},
		{
			MethodName: "GetRawTransactionByBlockNumberAndIndex",
			Handler:    _TransactionPoolReader_GetRawTransactionByBlockNumberAndIndex_Handler,
		},
		{
			MethodName: "GetTransactionByHash",
			Handler:    _TransactionPoolReader_GetTransactionByHash_Handler,
		},
		{
			MethodName: "GetTransactionReceipt",
			Handler:    _TransactionPoolReader_GetTransactionReceipt_Handler,
		},
		{
			MethodName: "GetTransactionCount",
			Handler:    _TransactionPoolReader_GetTransactionCount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/cpc/cpc.proto",
}

func init() { proto.RegisterFile("v1/cpc/cpc.proto", fileDescriptor_cpc_75fcbb1ca4015d93) }

var fileDescriptor_cpc_75fcbb1ca4015d93 = []byte{
	// 1024 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0x41, 0x6f, 0x1b, 0x45,
	0x14, 0xd6, 0xc6, 0x71, 0xe2, 0xbc, 0x34, 0x89, 0x3b, 0x76, 0x52, 0xd7, 0x31, 0x89, 0x3d, 0xb4,
	0xc1, 0x72, 0x8b, 0xad, 0xba, 0xa0, 0x46, 0x46, 0x20, 0xc5, 0x51, 0x31, 0x39, 0x04, 0xa2, 0x6d,
	0x1b, 0x04, 0x17, 0x18, 0xaf, 0xa7, 0xee, 0x2a, 0xf6, 0xcc, 0x76, 0x77, 0xdd, 0x60, 0x71, 0x82,
	0x03, 0xdc, 0xb8, 0x70, 0xe1, 0x80, 0xc4, 0x0f, 0xe0, 0xc6, 0x5f, 0xe1, 0x07, 0x70, 0xe9, 0x0f,
	0x41, 0xf3, 0x76, 0x36, 0xde, 0xdd, 0x78, 0x93, 0x08, 0x71, 0x68, 0xb3, 0xf3, 0xe6, 0xe5, 0xfb,
	0xbe, 0xf9, 0xe6, 0xbd, 0x37, 0x81, 0xfc, 0x9b, 0x47, 0x2d, 0xcb, 0xb1, 0xd4, 0xbf, 0xa6, 0xe3,
	0x4a, 0x5f, 0x92, 0x8c, 0xe5, 0x58, 0xe5, 0x82, 0x25, 0xc7, 0x63, 0x29, 0x5a, 0xc1, 0x8f, 0x60,
	0xa7, 0xbc, 0x3d, 0x94, 0x72, 0x38, 0xe2, 0x2d, 0x5c, 0xf5, 0x27, 0x2f, 0x5b, 0x7c, 0xec, 0xf8,
	0x53, 0xbd, 0xb9, 0x93, 0xdc, 0x3c, 0x77, 0x99, 0xe3, 0x70, 0xd7, 0xd3, 0xfb, 0x15, 0xbd, 0xcf,
	0x1c, 0xbb, 0xc5, 0x84, 0x90, 0x3e, 0xf3, 0x6d, 0x29, 0xf4, 0x2e, 0x15, 0x90, 0xfd, 0x52, 0xba,
	0x67, 0x1e, 0x79, 0x00, 0xd9, 0x73, 0xf5, 0x51, 0x32, 0xaa, 0x99, 0xfa, 0x6a, 0x7b, 0xb3, 0xa9,
	0x84, 0xe1, 0x56, 0xf0, 0xff, 0x53, 0xe1, 0xbb, 0x53, 0x33, 0xc8, 0x29, 0xef, 0x03, 0xcc, 0x82,
	0x24, 0x0f, 0x99, 0x33, 0x3e, 0x2d, 0x19, 0x55, 0xa3, 0x9e, 0x35, 0xd5, 0x27, 0x29, 0x42, 0xf6,
	0x0d, 0x1b, 0x4d, 0x78, 0x69, 0xa1, 0x6a, 0xd4, 0x57, 0xcc, 0x60, 0xd1, 0x59, 0xd8, 0x37, 0xe8,
	0x4f, 0x06, 0x90, 0xc3, 0x57, 0xcc, 0x16, 0x26, 0x67, 0x03, 0xee, 0x9a, 0xfc, 0xf5, 0x84, 0x7b,
	0x3e, 0x29, 0xc1, 0x32, 0x1b, 0x0c, 0x5c, 0xee, 0x79, 0x08, 0xb3, 0x62, 0x86, 0x4b, 0x52, 0x81,
	0x95, 0xfe, 0x48, 0x5a, 0x67, 0x9f, 0x31, 0xef, 0x95, 0x86, 0x9b, 0x05, 0x48, 0x15, 0x56, 0x71,
	0xf1, 0xf9, 0x64, 0xdc, 0xe7, 0x6e, 0x29, 0x53, 0x35, 0xea, 0x19, 0x33, 0x1a, 0x22, 0x5b, 0xb0,
	0x64, 0x7b, 0x9f, 0x4e, 0x46, 0xa3, 0xd2, 0x62, 0xd5, 0xa8, 0xe7, 0x4c, 0xbd, 0xa2, 0x9f, 0x40,
	0xfe, 0xb9, 0xcb, 0x84, 0xc7, 0x2c, 0x65, 0xc7, 0xa1, 0x9c, 0x08, 0x9f, 0x34, 0x20, 0xef, 0x27,
	0x62, 0x28, 0x67, 0xd1, 0xbc, 0x14, 0xa7, 0xbf, 0x18, 0x50, 0x89, 0x00, 0x9c, 0x48, 0x39, 0x8a,
	0x1f, 0x29, 0x21, 0x2d, 0xc0, 0x89, 0x49, 0x2b, 0x42, 0xd6, 0x16, 0x03, 0xfe, 0x1d, 0x1e, 0x6b,
	0xd1, 0x0c, 0x16, 0xf1, 0x03, 0x67, 0x92, 0x07, 0x8e, 0x18, 0xb5, 0x18, 0x33, 0x8a, 0xee, 0xc3,
	0xba, 0xc9, 0xce, 0x23, 0x92, 0xc8, 0x1e, 0xac, 0xbb, 0xb1, 0x08, 0x8a, 0xb8, 0x65, 0x26, 0xa2,
	0xf4, 0x23, 0xd8, 0x88, 0x2c, 0x91, 0xa6, 0x0e, 0x1b, 0x7e, 0x3c, 0xa4, 0xef, 0x25, 0x19, 0x6e,
	0x7f, 0x0b, 0xb9, 0x43, 0x69, 0x8b, 0x3e, 0xf3, 0x38, 0x79, 0x1e, 0xf9, 0xde, 0x6a, 0x06, 0x75,
	0xd7, 0x0c, 0xeb, 0xb2, 0xf9, 0x54, 0x15, 0x6d, 0x79, 0xa3, 0xa9, 0x4b, 0xfb, 0x40, 0xeb, 0xde,
	0xfd, 0xf1, 0xef, 0xb7, 0xbf, 0x2e, 0xdc, 0xa5, 0x45, 0xac, 0xd0, 0xb0, 0x2b, 0x34, 0x4c, 0xc7,
	0x68, 0xb4, 0xff, 0x34, 0x60, 0xf5, 0xd8, 0x16, 0xca, 0x59, 0xe5, 0x2f, 0x39, 0x86, 0xa5, 0x63,
	0x5b, 0xd8, 0x62, 0x98, 0xca, 0x71, 0x2b, 0xe4, 0x38, 0xf2, 0xbe, 0x38, 0xa3, 0xef, 0x20, 0xc1,
	0x1d, 0x4a, 0xa2, 0x04, 0x63, 0x44, 0xe8, 0x18, 0x0d, 0x72, 0x0c, 0xcb, 0x3d, 0xee, 0xab, 0x72,
	0x4e, 0xc5, 0x83, 0x59, 0x33, 0xd0, 0x1d, 0x44, 0x2b, 0xd1, 0x42, 0x14, 0x6d, 0x18, 0x00, 0x28,
	0xb5, 0x43, 0x58, 0x3b, 0xb0, 0x2c, 0x55, 0x22, 0x5a, 0xee, 0x29, 0xe4, 0x74, 0xc0, 0x4b, 0x25,
	0xb8, 0x9d, 0x30, 0x85, 0xa7, 0xd8, 0xc2, 0x34, 0x90, 0x22, 0xfa, 0x6b, 0x01, 0xf2, 0xd8, 0x49,
	0xcf, 0x7c, 0xe6, 0x73, 0x4d, 0xf6, 0x02, 0x72, 0x3d, 0xe6, 0x9d, 0xb8, 0xb6, 0x95, 0x7e, 0x03,
	0xf9, 0x90, 0x2c, 0xcc, 0x9c, 0xcf, 0x35, 0xd4, 0xbb, 0xca, 0x23, 0x09, 0x1b, 0x27, 0x0a, 0xc4,
	0x92, 0xa3, 0x53, 0xee, 0x7a, 0xaa, 0xb8, 0xd2, 0xd0, 0x2b, 0x97, 0xe2, 0x2f, 0x8e, 0x84, 0xff,
	0xb8, 0x7d, 0xaa, 0x46, 0x00, 0xdd, 0x43, 0xa6, 0x2a, 0xdd, 0x8e, 0x32, 0x39, 0x71, 0x68, 0x45,
	0x78, 0x0a, 0xcb, 0xcf, 0xa6, 0xc2, 0xba, 0xea, 0x92, 0x0b, 0xe1, 0x31, 0x74, 0xe2, 0x91, 0x78,
	0x29, 0xe7, 0xdf, 0x8e, 0x17, 0x24, 0x28, 0xd3, 0xde, 0x66, 0x60, 0x35, 0x32, 0x7e, 0x48, 0x1f,
	0xd6, 0x7a, 0xdc, 0xef, 0xaa, 0xf6, 0x0a, 0x46, 0xc0, 0xb5, 0x6c, 0xdd, 0x59, 0x03, 0xd3, 0x7b,
	0xc8, 0xb6, 0x43, 0xef, 0x26, 0x6a, 0x61, 0x86, 0xa7, 0xce, 0xf2, 0x15, 0x80, 0xe2, 0x60, 0x23,
	0x26, 0x2c, 0x4e, 0xee, 0x60, 0x2d, 0x5d, 0x1e, 0x81, 0xb3, 0xc6, 0xd0, 0x99, 0xb4, 0x86, 0xe8,
	0xdb, 0x74, 0x2b, 0x89, 0x1e, 0xec, 0x2b, 0x68, 0x0b, 0xf2, 0xa1, 0xfc, 0xee, 0x54, 0x4f, 0x95,
	0x54, 0x82, 0xb5, 0xd8, 0x11, 0xe8, 0x7b, 0x08, 0x5f, 0xa3, 0x95, 0x79, 0xe2, 0x43, 0x34, 0x45,
	0xf2, 0x0d, 0xac, 0xcf, 0x48, 0x70, 0x3a, 0xdc, 0x94, 0xe2, 0x3e, 0x52, 0xec, 0xd2, 0xf2, 0x7c,
	0x0a, 0x85, 0xa5, 0x08, 0x4e, 0xb0, 0x03, 0x0f, 0xe5, 0xe0, 0x0a, 0x77, 0x2e, 0x5a, 0x5a, 0xa5,
	0xa5, 0x36, 0xa1, 0x25, 0x07, 0x38, 0x32, 0xfe, 0xc9, 0xc1, 0xe6, 0xdc, 0xe1, 0x4c, 0x7e, 0x36,
	0xa0, 0xda, 0xe3, 0x7e, 0x72, 0xf4, 0x77, 0xa7, 0x91, 0x7b, 0x25, 0xf3, 0x2e, 0xbb, 0x1c, 0xbc,
	0x88, 0xc9, 0x5f, 0xa4, 0x4f, 0x50, 0xca, 0x23, 0xfa, 0x30, 0x21, 0xe5, 0x4a, 0x06, 0x75, 0xea,
	0x1f, 0x0c, 0xd8, 0x49, 0x57, 0x82, 0x3e, 0xdf, 0x8e, 0xe9, 0x50, 0xa1, 0x34, 0x15, 0x1f, 0xa2,
	0x8a, 0x16, 0x6d, 0xdc, 0x4c, 0x45, 0xe8, 0xfc, 0xef, 0x06, 0xbc, 0x1b, 0xd7, 0x10, 0x93, 0x79,
	0x20, 0x06, 0x47, 0xf8, 0x26, 0xd5, 0x92, 0xac, 0x97, 0x9e, 0xbb, 0xf2, 0x56, 0xa8, 0xd5, 0x74,
	0xac, 0xe8, 0xe3, 0xd2, 0x41, 0x65, 0x1f, 0xd0, 0x56, 0xba, 0xb2, 0xb9, 0x9c, 0x4a, 0xde, 0x6f,
	0x06, 0xd4, 0xe6, 0xca, 0x53, 0xfa, 0xff, 0x0f, 0x71, 0xfb, 0x28, 0xae, 0x4d, 0xdf, 0xbf, 0x56,
	0x5c, 0x94, 0x51, 0x49, 0xfb, 0xc3, 0x80, 0xbd, 0x1e, 0xf7, 0xe3, 0x2f, 0xee, 0x7f, 0x36, 0xaf,
	0x80, 0x29, 0x71, 0x30, 0xfa, 0x31, 0x8a, 0x7b, 0x42, 0xdb, 0x09, 0x71, 0x37, 0xe0, 0x54, 0x0a,
	0x5f, 0x43, 0x31, 0xe9, 0x1d, 0x16, 0x55, 0x31, 0x29, 0x07, 0xeb, 0x2a, 0xcd, 0xa1, 0x07, 0x28,
	0xe2, 0x3e, 0xad, 0x5e, 0xe5, 0x50, 0x58, 0x4e, 0x23, 0xd8, 0x8c, 0x53, 0x9a, 0xdc, 0xe2, 0xb6,
	0xe3, 0xa7, 0x70, 0x5e, 0x4c, 0x3c, 0x9d, 0x46, 0x1f, 0x22, 0xd9, 0x1e, 0xad, 0xa5, 0x93, 0xe9,
	0x54, 0xc5, 0xf6, 0x3d, 0x14, 0xe6, 0xf4, 0xcf, 0x4d, 0xec, 0x4e, 0x69, 0xa2, 0x06, 0xd2, 0xdf,
	0xa3, 0xbb, 0xd7, 0x34, 0x51, 0xc7, 0x68, 0x74, 0xb3, 0x5f, 0xab, 0x3f, 0xd7, 0xfb, 0x4b, 0xf8,
	0x4c, 0x3c, 0xfe, 0x37, 0x00, 0x00, 0xff, 0xff, 0x78, 0xbe, 0x1f, 0x8d, 0xce, 0x0b, 0x00, 0x00,
}
