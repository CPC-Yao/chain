// Code generated by protoc-gen-go. DO NOT EDIT.
// source: miner.proto

package protos

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	context "golang.org/x/net/context"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Threads struct {
	Threads              uint32   `protobuf:"varint,1,opt,name=threads,proto3" json:"threads,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Threads) Reset()         { *m = Threads{} }
func (m *Threads) String() string { return proto.CompactTextString(m) }
func (*Threads) ProtoMessage()    {}
func (*Threads) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e7fcaacee94c057, []int{0}
}

func (m *Threads) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Threads.Unmarshal(m, b)
}
func (m *Threads) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Threads.Marshal(b, m, deterministic)
}
func (m *Threads) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Threads.Merge(m, src)
}
func (m *Threads) XXX_Size() int {
	return xxx_messageInfo_Threads.Size(m)
}
func (m *Threads) XXX_DiscardUnknown() {
	xxx_messageInfo_Threads.DiscardUnknown(m)
}

var xxx_messageInfo_Threads proto.InternalMessageInfo

func (m *Threads) GetThreads() uint32 {
	if m != nil {
		return m.Threads
	}
	return 0
}

type Extra struct {
	Extra                string   `protobuf:"bytes,1,opt,name=extra,proto3" json:"extra,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Extra) Reset()         { *m = Extra{} }
func (m *Extra) String() string { return proto.CompactTextString(m) }
func (*Extra) ProtoMessage()    {}
func (*Extra) Descriptor() ([]byte, []int) {
	return fileDescriptor_6e7fcaacee94c057, []int{1}
}

func (m *Extra) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Extra.Unmarshal(m, b)
}
func (m *Extra) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Extra.Marshal(b, m, deterministic)
}
func (m *Extra) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Extra.Merge(m, src)
}
func (m *Extra) XXX_Size() int {
	return xxx_messageInfo_Extra.Size(m)
}
func (m *Extra) XXX_DiscardUnknown() {
	xxx_messageInfo_Extra.DiscardUnknown(m)
}

var xxx_messageInfo_Extra proto.InternalMessageInfo

func (m *Extra) GetExtra() string {
	if m != nil {
		return m.Extra
	}
	return ""
}

func init() {
	proto.RegisterType((*Threads)(nil), "protos.Threads")
	proto.RegisterType((*Extra)(nil), "protos.Extra")
}

func init() { proto.RegisterFile("miner.proto", fileDescriptor_6e7fcaacee94c057) }

var fileDescriptor_6e7fcaacee94c057 = []byte{
	// 361 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x92, 0xd1, 0x4a, 0xeb, 0x30,
	0x18, 0xc7, 0xe9, 0x39, 0x67, 0x67, 0xe7, 0x64, 0x1b, 0x4a, 0x94, 0x39, 0x3b, 0x37, 0x34, 0x7a,
	0x21, 0x43, 0x52, 0xd4, 0xbb, 0xdd, 0xa9, 0x0c, 0x51, 0x19, 0x8e, 0xd5, 0x2b, 0xef, 0xd2, 0x2e,
	0x76, 0x61, 0x36, 0x29, 0x49, 0x26, 0x7a, 0xeb, 0x2b, 0xf8, 0x06, 0xbe, 0x92, 0xaf, 0xe0, 0x83,
	0x48, 0x92, 0x06, 0xa1, 0x22, 0x78, 0xd3, 0xe4, 0xff, 0x7d, 0xfd, 0xff, 0xbe, 0xff, 0x57, 0x0a,
	0x1a, 0x39, 0xe3, 0x54, 0xe2, 0x42, 0x0a, 0x2d, 0xe0, 0x5f, 0x7b, 0xa8, 0xb0, 0x99, 0x8a, 0x3c,
	0x17, 0xdc, 0x55, 0xc3, 0x6e, 0x26, 0x44, 0x76, 0x4f, 0x23, 0xab, 0x92, 0xe5, 0x5d, 0x44, 0xf3,
	0x42, 0x3f, 0x95, 0xcd, 0xad, 0xb2, 0x49, 0x0a, 0x16, 0x11, 0xce, 0x85, 0x26, 0x9a, 0x09, 0xae,
	0x5c, 0x17, 0xed, 0x82, 0xfa, 0xcd, 0x5c, 0x52, 0x32, 0x53, 0xb0, 0x03, 0xea, 0xda, 0x5d, 0x3b,
	0xc1, 0x76, 0xb0, 0xdf, 0x9a, 0x7a, 0x89, 0x7a, 0xa0, 0x36, 0x7a, 0xd4, 0x92, 0xc0, 0x75, 0x50,
	0xa3, 0xe6, 0x62, 0x5f, 0xf8, 0x3f, 0x75, 0xe2, 0xe8, 0xf5, 0x37, 0x68, 0x8e, 0x4d, 0xc8, 0x31,
	0xe1, 0x24, 0xa3, 0x12, 0x4e, 0x40, 0x2d, 0xd6, 0x44, 0x6a, 0xb8, 0xe2, 0xa6, 0x28, 0x5c, 0xce,
	0x08, 0xdb, 0xd8, 0xa5, 0xc1, 0x3e, 0x2a, 0x1e, 0x99, 0xa8, 0xa8, 0xff, 0xfc, 0xf6, 0xfe, 0xf2,
	0xab, 0x83, 0xd6, 0x6c, 0xcc, 0x87, 0xc3, 0xc8, 0x2e, 0x1d, 0x29, 0x43, 0x19, 0x06, 0x03, 0x78,
	0x05, 0xfe, 0xc4, 0x5a, 0x14, 0xf0, 0x1b, 0x7f, 0xd8, 0xf4, 0x83, 0x2e, 0xd4, 0xf5, 0x02, 0xf5,
	0x2c, 0x6d, 0x03, 0xc1, 0x2a, 0x4d, 0x14, 0x06, 0x76, 0x09, 0xfe, 0xc5, 0x54, 0xbb, 0x8d, 0x5a,
	0xde, 0x68, 0x65, 0x85, 0xb3, 0x63, 0x39, 0x5d, 0xd4, 0xae, 0x70, 0x4a, 0xb3, 0x61, 0xc5, 0xa0,
	0x11, 0x53, 0x7d, 0x4e, 0xd4, 0x44, 0xb2, 0x94, 0xc2, 0x55, 0xef, 0xf7, 0x95, 0x0a, 0x71, 0xcf,
	0x12, 0xfb, 0x68, 0xf3, 0x0b, 0xd1, 0x1b, 0x0c, 0x74, 0x6a, 0xa1, 0x67, 0x82, 0xf1, 0x84, 0x28,
	0xfa, 0xf9, 0x15, 0x4f, 0x66, 0x33, 0x49, 0x95, 0xfa, 0x31, 0xd3, 0x13, 0x86, 0xc1, 0xe0, 0xf4,
	0x00, 0x20, 0x21, 0x33, 0x9c, 0x30, 0x9d, 0x2c, 0xd3, 0x05, 0xd5, 0x38, 0x2d, 0xd2, 0x39, 0x61,
	0x1c, 0xbb, 0xa7, 0x03, 0xde, 0x96, 0xff, 0x57, 0xe2, 0xce, 0xe3, 0x8f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x9c, 0xd0, 0xa3, 0x2c, 0x7d, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MinerManagerClient is the client API for MinerManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MinerManagerClient interface {
	// Start the miner with the given number of threads. If threads is nil the number
	// of workers started is equal to the number of logical CPUs that are usable by
	// this process. If mining is already running, this method adjust the number of
	// threads allowed to use.
	Start(ctx context.Context, in *Threads, opts ...grpc.CallOption) (*empty.Empty, error)
	Stop(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsOk, error)
	SetExtra(ctx context.Context, in *Extra, opts ...grpc.CallOption) (*IsOk, error)
	SetGasPrice(ctx context.Context, in *GasPrice, opts ...grpc.CallOption) (*IsOk, error)
	SetCoinbase(ctx context.Context, in *Address, opts ...grpc.CallOption) (*IsOk, error)
}

type minerManagerClient struct {
	cc *grpc.ClientConn
}

func NewMinerManagerClient(cc *grpc.ClientConn) MinerManagerClient {
	return &minerManagerClient{cc}
}

func (c *minerManagerClient) Start(ctx context.Context, in *Threads, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/protos.MinerManager/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *minerManagerClient) Stop(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsOk, error) {
	out := new(IsOk)
	err := c.cc.Invoke(ctx, "/protos.MinerManager/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *minerManagerClient) SetExtra(ctx context.Context, in *Extra, opts ...grpc.CallOption) (*IsOk, error) {
	out := new(IsOk)
	err := c.cc.Invoke(ctx, "/protos.MinerManager/SetExtra", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *minerManagerClient) SetGasPrice(ctx context.Context, in *GasPrice, opts ...grpc.CallOption) (*IsOk, error) {
	out := new(IsOk)
	err := c.cc.Invoke(ctx, "/protos.MinerManager/SetGasPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *minerManagerClient) SetCoinbase(ctx context.Context, in *Address, opts ...grpc.CallOption) (*IsOk, error) {
	out := new(IsOk)
	err := c.cc.Invoke(ctx, "/protos.MinerManager/SetCoinbase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MinerManagerServer is the server API for MinerManager service.
type MinerManagerServer interface {
	// Start the miner with the given number of threads. If threads is nil the number
	// of workers started is equal to the number of logical CPUs that are usable by
	// this process. If mining is already running, this method adjust the number of
	// threads allowed to use.
	Start(context.Context, *Threads) (*empty.Empty, error)
	Stop(context.Context, *empty.Empty) (*IsOk, error)
	SetExtra(context.Context, *Extra) (*IsOk, error)
	SetGasPrice(context.Context, *GasPrice) (*IsOk, error)
	SetCoinbase(context.Context, *Address) (*IsOk, error)
}

func RegisterMinerManagerServer(s *grpc.Server, srv MinerManagerServer) {
	s.RegisterService(&_MinerManager_serviceDesc, srv)
}

func _MinerManager_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Threads)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerManagerServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.MinerManager/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerManagerServer).Start(ctx, req.(*Threads))
	}
	return interceptor(ctx, in, info, handler)
}

func _MinerManager_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerManagerServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.MinerManager/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerManagerServer).Stop(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MinerManager_SetExtra_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Extra)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerManagerServer).SetExtra(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.MinerManager/SetExtra",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerManagerServer).SetExtra(ctx, req.(*Extra))
	}
	return interceptor(ctx, in, info, handler)
}

func _MinerManager_SetGasPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GasPrice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerManagerServer).SetGasPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.MinerManager/SetGasPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerManagerServer).SetGasPrice(ctx, req.(*GasPrice))
	}
	return interceptor(ctx, in, info, handler)
}

func _MinerManager_SetCoinbase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerManagerServer).SetCoinbase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.MinerManager/SetCoinbase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerManagerServer).SetCoinbase(ctx, req.(*Address))
	}
	return interceptor(ctx, in, info, handler)
}

var _MinerManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.MinerManager",
	HandlerType: (*MinerManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _MinerManager_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _MinerManager_Stop_Handler,
		},
		{
			MethodName: "SetExtra",
			Handler:    _MinerManager_SetExtra_Handler,
		},
		{
			MethodName: "SetGasPrice",
			Handler:    _MinerManager_SetGasPrice_Handler,
		},
		{
			MethodName: "SetCoinbase",
			Handler:    _MinerManager_SetCoinbase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "miner.proto",
}
