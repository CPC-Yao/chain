// Code generated by protoc-gen-go. DO NOT EDIT.
// source: cpc.proto

package protos

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	context "golang.org/x/net/context"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ChainReaderRequest struct {
	Address              string   `protobuf:"bytes,1,opt,name=address,proto3" json:"address,omitempty"`
	BlockHash            string   `protobuf:"bytes,2,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	BlockNumber          int64    `protobuf:"varint,3,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	IsFull               bool     `protobuf:"varint,4,opt,name=is_full,json=isFull,proto3" json:"is_full,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChainReaderRequest) Reset()         { *m = ChainReaderRequest{} }
func (m *ChainReaderRequest) String() string { return proto.CompactTextString(m) }
func (*ChainReaderRequest) ProtoMessage()    {}
func (*ChainReaderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_423c627df4983bea, []int{0}
}

func (m *ChainReaderRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ChainReaderRequest.Unmarshal(m, b)
}
func (m *ChainReaderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ChainReaderRequest.Marshal(b, m, deterministic)
}
func (m *ChainReaderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainReaderRequest.Merge(m, src)
}
func (m *ChainReaderRequest) XXX_Size() int {
	return xxx_messageInfo_ChainReaderRequest.Size(m)
}
func (m *ChainReaderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainReaderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChainReaderRequest proto.InternalMessageInfo

func (m *ChainReaderRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ChainReaderRequest) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *ChainReaderRequest) GetBlockNumber() int64 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *ChainReaderRequest) GetIsFull() bool {
	if m != nil {
		return m.IsFull
	}
	return false
}

type TransactionCount struct {
	TransactionCount     uint64   `protobuf:"varint,1,opt,name=transaction_count,json=transactionCount,proto3" json:"transaction_count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionCount) Reset()         { *m = TransactionCount{} }
func (m *TransactionCount) String() string { return proto.CompactTextString(m) }
func (*TransactionCount) ProtoMessage()    {}
func (*TransactionCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_423c627df4983bea, []int{1}
}

func (m *TransactionCount) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionCount.Unmarshal(m, b)
}
func (m *TransactionCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionCount.Marshal(b, m, deterministic)
}
func (m *TransactionCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionCount.Merge(m, src)
}
func (m *TransactionCount) XXX_Size() int {
	return xxx_messageInfo_TransactionCount.Size(m)
}
func (m *TransactionCount) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionCount.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionCount proto.InternalMessageInfo

func (m *TransactionCount) GetTransactionCount() uint64 {
	if m != nil {
		return m.TransactionCount
	}
	return 0
}

type TransactionPoolReaderRequest struct {
	BlockNumber          uint64   `protobuf:"varint,1,opt,name=block_number,json=blockNumber,proto3" json:"block_number,omitempty"`
	Index                uint64   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	BlockHash            string   `protobuf:"bytes,3,opt,name=block_hash,json=blockHash,proto3" json:"block_hash,omitempty"`
	Address              string   `protobuf:"bytes,4,opt,name=address,proto3" json:"address,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionPoolReaderRequest) Reset()         { *m = TransactionPoolReaderRequest{} }
func (m *TransactionPoolReaderRequest) String() string { return proto.CompactTextString(m) }
func (*TransactionPoolReaderRequest) ProtoMessage()    {}
func (*TransactionPoolReaderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_423c627df4983bea, []int{2}
}

func (m *TransactionPoolReaderRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionPoolReaderRequest.Unmarshal(m, b)
}
func (m *TransactionPoolReaderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionPoolReaderRequest.Marshal(b, m, deterministic)
}
func (m *TransactionPoolReaderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionPoolReaderRequest.Merge(m, src)
}
func (m *TransactionPoolReaderRequest) XXX_Size() int {
	return xxx_messageInfo_TransactionPoolReaderRequest.Size(m)
}
func (m *TransactionPoolReaderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionPoolReaderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionPoolReaderRequest proto.InternalMessageInfo

func (m *TransactionPoolReaderRequest) GetBlockNumber() uint64 {
	if m != nil {
		return m.BlockNumber
	}
	return 0
}

func (m *TransactionPoolReaderRequest) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *TransactionPoolReaderRequest) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *TransactionPoolReaderRequest) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

type RawTransaction struct {
	RawTransaction       []byte   `protobuf:"bytes,1,opt,name=raw_transaction,json=rawTransaction,proto3" json:"raw_transaction,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RawTransaction) Reset()         { *m = RawTransaction{} }
func (m *RawTransaction) String() string { return proto.CompactTextString(m) }
func (*RawTransaction) ProtoMessage()    {}
func (*RawTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_423c627df4983bea, []int{3}
}

func (m *RawTransaction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RawTransaction.Unmarshal(m, b)
}
func (m *RawTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RawTransaction.Marshal(b, m, deterministic)
}
func (m *RawTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawTransaction.Merge(m, src)
}
func (m *RawTransaction) XXX_Size() int {
	return xxx_messageInfo_RawTransaction.Size(m)
}
func (m *RawTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_RawTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_RawTransaction proto.InternalMessageInfo

func (m *RawTransaction) GetRawTransaction() []byte {
	if m != nil {
		return m.RawTransaction
	}
	return nil
}

type TransactionHash struct {
	TransactionHash      string   `protobuf:"bytes,1,opt,name=transaction_hash,json=transactionHash,proto3" json:"transaction_hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransactionHash) Reset()         { *m = TransactionHash{} }
func (m *TransactionHash) String() string { return proto.CompactTextString(m) }
func (*TransactionHash) ProtoMessage()    {}
func (*TransactionHash) Descriptor() ([]byte, []int) {
	return fileDescriptor_423c627df4983bea, []int{4}
}

func (m *TransactionHash) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TransactionHash.Unmarshal(m, b)
}
func (m *TransactionHash) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TransactionHash.Marshal(b, m, deterministic)
}
func (m *TransactionHash) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransactionHash.Merge(m, src)
}
func (m *TransactionHash) XXX_Size() int {
	return xxx_messageInfo_TransactionHash.Size(m)
}
func (m *TransactionHash) XXX_DiscardUnknown() {
	xxx_messageInfo_TransactionHash.DiscardUnknown(m)
}

var xxx_messageInfo_TransactionHash proto.InternalMessageInfo

func (m *TransactionHash) GetTransactionHash() string {
	if m != nil {
		return m.TransactionHash
	}
	return ""
}

type Works struct {
	Works                map[int32]string `protobuf:"bytes,1,rep,name=works,proto3" json:"works,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *Works) Reset()         { *m = Works{} }
func (m *Works) String() string { return proto.CompactTextString(m) }
func (*Works) ProtoMessage()    {}
func (*Works) Descriptor() ([]byte, []int) {
	return fileDescriptor_423c627df4983bea, []int{5}
}

func (m *Works) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Works.Unmarshal(m, b)
}
func (m *Works) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Works.Marshal(b, m, deterministic)
}
func (m *Works) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Works.Merge(m, src)
}
func (m *Works) XXX_Size() int {
	return xxx_messageInfo_Works.Size(m)
}
func (m *Works) XXX_DiscardUnknown() {
	xxx_messageInfo_Works.DiscardUnknown(m)
}

var xxx_messageInfo_Works proto.InternalMessageInfo

func (m *Works) GetWorks() map[int32]string {
	if m != nil {
		return m.Works
	}
	return nil
}

func init() {
	proto.RegisterType((*ChainReaderRequest)(nil), "protos.ChainReaderRequest")
	proto.RegisterType((*TransactionCount)(nil), "protos.TransactionCount")
	proto.RegisterType((*TransactionPoolReaderRequest)(nil), "protos.TransactionPoolReaderRequest")
	proto.RegisterType((*RawTransaction)(nil), "protos.RawTransaction")
	proto.RegisterType((*TransactionHash)(nil), "protos.TransactionHash")
	proto.RegisterType((*Works)(nil), "protos.Works")
	proto.RegisterMapType((map[int32]string)(nil), "protos.Works.WorksEntry")
}

func init() { proto.RegisterFile("cpc.proto", fileDescriptor_423c627df4983bea) }

var fileDescriptor_423c627df4983bea = []byte{
	// 901 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x96, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xc7, 0x35, 0x71, 0x3e, 0x4f, 0x3e, 0x99, 0xa4, 0x8d, 0xeb, 0xa6, 0x89, 0x3d, 0xa4, 0x6d,
	0x70, 0xc3, 0x5a, 0x35, 0xa0, 0x06, 0x0b, 0x84, 0xea, 0xa8, 0x84, 0x5e, 0x04, 0xaa, 0x55, 0x25,
	0x24, 0x84, 0x64, 0x66, 0xd7, 0x53, 0x67, 0xe5, 0xf5, 0xac, 0xb3, 0x3b, 0x6e, 0xf0, 0x25, 0x5c,
	0x20, 0xc1, 0x15, 0x12, 0x5c, 0x70, 0xc1, 0x15, 0x0f, 0xc0, 0xcb, 0xf0, 0x0a, 0x3c, 0x04, 0x97,
	0x68, 0xce, 0xec, 0xc6, 0xbb, 0xdb, 0x75, 0x9a, 0x4a, 0xbd, 0xd9, 0xdd, 0x39, 0x67, 0x7c, 0xfe,
	0xbf, 0x73, 0xe6, 0xcc, 0x8c, 0x61, 0xc9, 0x1d, 0xba, 0xd6, 0x30, 0x0c, 0x54, 0x40, 0xe7, 0xf1,
	0x15, 0x55, 0x56, 0xdc, 0x60, 0x30, 0x08, 0xa4, 0xb1, 0x56, 0x6e, 0xf7, 0x82, 0xa0, 0xe7, 0x8b,
	0x06, 0x8e, 0x9c, 0xd1, 0x8b, 0x86, 0x18, 0x0c, 0xd5, 0x38, 0x76, 0xee, 0xc4, 0x4e, 0x3e, 0xf4,
	0x1a, 0x5c, 0xca, 0x40, 0x71, 0xe5, 0x05, 0x32, 0x32, 0x5e, 0xf6, 0x33, 0x01, 0x7a, 0x7c, 0xc6,
	0x3d, 0x69, 0x0b, 0xde, 0x15, 0xa1, 0x2d, 0xce, 0x47, 0x22, 0x52, 0xb4, 0x0c, 0x0b, 0xbc, 0xdb,
	0x0d, 0x45, 0x14, 0x95, 0x49, 0x95, 0x1c, 0x2c, 0xd9, 0xc9, 0x90, 0xde, 0x01, 0x70, 0xfc, 0xc0,
	0xed, 0x77, 0xce, 0x78, 0x74, 0x56, 0x9e, 0x41, 0xe7, 0x12, 0x5a, 0xbe, 0xe0, 0xd1, 0x19, 0xad,
	0xc1, 0x8a, 0x71, 0xcb, 0xd1, 0xc0, 0x11, 0x61, 0xb9, 0x54, 0x25, 0x07, 0x25, 0x7b, 0x19, 0x6d,
	0x5f, 0xa2, 0x89, 0x6e, 0xc3, 0x82, 0x17, 0x75, 0x5e, 0x8c, 0x7c, 0xbf, 0x3c, 0x5b, 0x25, 0x07,
	0x8b, 0xf6, 0xbc, 0x17, 0x7d, 0x3e, 0xf2, 0x7d, 0xf6, 0x19, 0x6c, 0x3c, 0x0f, 0xb9, 0x8c, 0xb8,
	0xab, 0x09, 0x8f, 0x83, 0x91, 0x54, 0xf4, 0x01, 0xbc, 0xa3, 0x26, 0xb6, 0x8e, 0xab, 0x8d, 0x88,
	0x34, 0x6b, 0x6f, 0xa8, 0xdc, 0x64, 0xf6, 0x2b, 0x81, 0x9d, 0x54, 0x84, 0x67, 0x41, 0xe0, 0x67,
	0xd3, 0xca, 0xd3, 0x99, 0x40, 0x19, 0xba, 0x2d, 0x98, 0xf3, 0x64, 0x57, 0x7c, 0x8f, 0xa9, 0xcd,
	0xda, 0x66, 0x90, 0xcb, 0xba, 0x94, 0xcf, 0x3a, 0x55, 0xae, 0xd9, 0x4c, 0xb9, 0xd8, 0xc7, 0xb0,
	0x66, 0xf3, 0x8b, 0x14, 0x14, 0xbd, 0x0f, 0xeb, 0x21, 0xbf, 0xe8, 0xa4, 0xe0, 0x11, 0x63, 0xc5,
	0x5e, 0x0b, 0x33, 0x13, 0xd9, 0x27, 0xb0, 0x9e, 0x1a, 0xa2, 0xce, 0x7b, 0x90, 0x4e, 0xda, 0xc0,
	0x98, 0xf5, 0x59, 0x57, 0xd9, 0xa9, 0xec, 0x1c, 0xe6, 0xbe, 0x0e, 0xc2, 0x7e, 0x44, 0x2d, 0x98,
	0xbb, 0xd0, 0x1f, 0x65, 0x52, 0x2d, 0x1d, 0x2c, 0x37, 0xcb, 0x66, 0xe1, 0x23, 0x0b, 0xbd, 0xe6,
	0xf9, 0x44, 0xaa, 0x70, 0x6c, 0x9b, 0x69, 0x95, 0x23, 0x80, 0x89, 0x91, 0x6e, 0x40, 0xa9, 0x2f,
	0xc6, 0x28, 0x32, 0x67, 0xeb, 0x4f, 0x5d, 0xa0, 0x97, 0xdc, 0x1f, 0x89, 0x78, 0xed, 0xcd, 0xa0,
	0x35, 0x73, 0x44, 0x9a, 0xbf, 0x97, 0x60, 0x39, 0xd5, 0x4b, 0xd4, 0x81, 0xd5, 0x13, 0xa1, 0xda,
	0xba, 0x4a, 0x66, 0x31, 0x6f, 0x5a, 0xa6, 0x17, 0xad, 0xa4, 0x51, 0xad, 0x27, 0xba, 0x51, 0x2b,
	0x9b, 0x09, 0x53, 0x7b, 0xb2, 0x10, 0x6c, 0xff, 0xc7, 0x7f, 0xfe, 0xfd, 0x6d, 0x66, 0x97, 0xdd,
	0xc2, 0xce, 0x7d, 0xf9, 0xb0, 0xe1, 0x0e, 0xdd, 0x46, 0x2f, 0x1d, 0xaf, 0x45, 0xea, 0xf4, 0x5b,
	0x00, 0xad, 0xc1, 0x7d, 0x2e, 0x5d, 0x41, 0x2b, 0x49, 0xa0, 0x57, 0x5b, 0xba, 0xb2, 0x7e, 0x29,
	0x62, 0x26, 0xb3, 0x1a, 0x0a, 0xdc, 0x66, 0x37, 0xf3, 0x02, 0xc6, 0xaf, 0xa3, 0x77, 0x60, 0x23,
	0xc9, 0xa0, 0x3d, 0x8e, 0x1b, 0xa4, 0x08, 0xb6, 0xb2, 0x9a, 0x31, 0xb2, 0xfb, 0x18, 0xba, 0xc6,
	0x76, 0x8a, 0xd8, 0x93, 0x48, 0x5a, 0xc0, 0x81, 0xb5, 0x89, 0x00, 0x2e, 0xf1, 0x55, 0x29, 0xe4,
	0x54, 0xee, 0xa2, 0xca, 0x1e, 0xab, 0x14, 0xab, 0xe8, 0x70, 0x2d, 0x52, 0x6f, 0xfe, 0xb7, 0x08,
	0x37, 0x0a, 0x77, 0x05, 0xfd, 0x85, 0x40, 0xf5, 0x44, 0xa8, 0xfc, 0xa6, 0x6b, 0x8f, 0x53, 0xa9,
	0x15, 0xe7, 0x7b, 0xd9, 0x45, 0xf9, 0xdf, 0xb2, 0x47, 0x08, 0xf5, 0x90, 0x1d, 0xe6, 0xa0, 0xae,
	0x14, 0xd1, 0xa5, 0xf8, 0x89, 0xc0, 0xee, 0x74, 0x18, 0xac, 0xcd, 0x1b, 0xa2, 0x7c, 0x84, 0x28,
	0x0d, 0x56, 0xbf, 0x1e, 0x4a, 0x5c, 0x2f, 0xfa, 0x27, 0x81, 0x77, 0xb3, 0x20, 0x19, 0xd6, 0xc7,
	0xb2, 0xfb, 0x14, 0xcf, 0x84, 0xfd, 0x02, 0xe1, 0x57, 0x8e, 0x9c, 0x49, 0x6f, 0xa7, 0xb7, 0x76,
	0x0b, 0xc9, 0x3e, 0x64, 0x8d, 0xe9, 0x64, 0x85, 0x9a, 0x1a, 0xef, 0x0f, 0x02, 0xb5, 0x42, 0x3c,
	0xcd, 0xff, 0x36, 0xe0, 0x8e, 0x10, 0xae, 0xc9, 0xde, 0x7f, 0x2d, 0x5c, 0x5a, 0x51, 0xa3, 0xfd,
	0x45, 0xe0, 0xde, 0x89, 0x50, 0xd9, 0x03, 0xef, 0xad, 0x17, 0xef, 0x53, 0xe4, 0x7b, 0xc4, 0x9a,
	0x39, 0xbe, 0x6b, 0xc8, 0x6a, 0xc8, 0x73, 0xd8, 0xca, 0x97, 0x0f, 0x9b, 0x6b, 0xbb, 0x40, 0x4b,
	0x3b, 0x8a, 0x21, 0x1e, 0x20, 0xc4, 0x5d, 0x56, 0xbd, 0xaa, 0x48, 0x49, 0x47, 0x45, 0x70, 0x23,
	0x2b, 0x69, 0x0b, 0x57, 0x78, 0x43, 0xf5, 0x86, 0x9a, 0x87, 0xa8, 0x79, 0x8f, 0xd5, 0xa6, 0x6b,
	0xc6, 0x81, 0xb5, 0xe8, 0x0f, 0x04, 0x36, 0x0b, 0xf6, 0xd3, 0x35, 0x2b, 0x3f, 0x7d, 0x57, 0xd5,
	0x91, 0x62, 0x9f, 0xed, 0xbd, 0x66, 0x57, 0xe9, 0xa3, 0xe7, 0x3b, 0x58, 0x3c, 0x0e, 0x3c, 0xe9,
	0xf0, 0x48, 0xd0, 0xe7, 0xa9, 0xef, 0x69, 0x17, 0xc1, 0xe5, 0x19, 0xfd, 0x38, 0xbe, 0x3e, 0xf7,
	0x50, 0xec, 0x16, 0xdb, 0x4a, 0x8b, 0xb9, 0x71, 0x18, 0xad, 0xf0, 0x37, 0x81, 0xe5, 0x53, 0x4f,
	0x6a, 0x70, 0x3c, 0xd2, 0x4e, 0x61, 0xfe, 0xd4, 0x93, 0x9e, 0xec, 0x4d, 0xd5, 0x58, 0x49, 0x34,
	0x9e, 0x46, 0x5f, 0xf5, 0xd9, 0x1d, 0x14, 0xd8, 0x66, 0x34, 0x2d, 0x30, 0xc0, 0x08, 0xba, 0x88,
	0xcf, 0x60, 0xe1, 0x44, 0x28, 0x7d, 0x1f, 0x4e, 0x8d, 0xb7, 0x9a, 0xb9, 0x50, 0xd9, 0x2e, 0x06,
	0x2c, 0xb3, 0xcd, 0x5c, 0x79, 0xb4, 0xb7, 0x45, 0xea, 0xed, 0x43, 0x60, 0x41, 0xd8, 0xb3, 0x1c,
	0x4f, 0x39, 0x23, 0xb7, 0x2f, 0x94, 0xe5, 0x0e, 0x5d, 0x7d, 0xd2, 0x5b, 0xe6, 0x69, 0x62, 0x7d,
	0x13, 0xff, 0xcf, 0x73, 0xcc, 0xfb, 0x83, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x7b, 0x99, 0xb3,
	0x50, 0x03, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ChainReaderClient is the client API for ChainReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ChainReaderClient interface {
	// GetBlockCount returns the block number of the chain head.
	GetBlockCount(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BlockNumber, error)
	// GetBalance returns the amount of wei for the given address in the state of the
	// given block number. The rpc.LatestBlockNumber and rpc.PendingBlockNumber meta
	// block numbers are also allowed.
	GetBalance(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*Balance, error)
	// GetBlockByNumber returns the requested block. When blockNr is -1 the chain head is returned. When fullTx is true all
	// transactions in the block are returned in full detail, otherwise only the transaction hash is returned.
	GetBlockByNumber(ctx context.Context, in *BlockNumber, opts ...grpc.CallOption) (*Block, error)
	// GetBlockByHash returns the requested block. When fullTx is true all transactions in the block are returned in full
	// detail, otherwise only the transaction hash is returned.
	GetBlockByHash(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*Block, error)
}

type chainReaderClient struct {
	cc *grpc.ClientConn
}

func NewChainReaderClient(cc *grpc.ClientConn) ChainReaderClient {
	return &chainReaderClient{cc}
}

func (c *chainReaderClient) GetBlockCount(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*BlockNumber, error) {
	out := new(BlockNumber)
	err := c.cc.Invoke(ctx, "/protos.ChainReader/GetBlockCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainReaderClient) GetBalance(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*Balance, error) {
	out := new(Balance)
	err := c.cc.Invoke(ctx, "/protos.ChainReader/GetBalance", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainReaderClient) GetBlockByNumber(ctx context.Context, in *BlockNumber, opts ...grpc.CallOption) (*Block, error) {
	out := new(Block)
	err := c.cc.Invoke(ctx, "/protos.ChainReader/GetBlockByNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainReaderClient) GetBlockByHash(ctx context.Context, in *ChainReaderRequest, opts ...grpc.CallOption) (*Block, error) {
	out := new(Block)
	err := c.cc.Invoke(ctx, "/protos.ChainReader/GetBlockByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChainReaderServer is the server API for ChainReader service.
type ChainReaderServer interface {
	// GetBlockCount returns the block number of the chain head.
	GetBlockCount(context.Context, *empty.Empty) (*BlockNumber, error)
	// GetBalance returns the amount of wei for the given address in the state of the
	// given block number. The rpc.LatestBlockNumber and rpc.PendingBlockNumber meta
	// block numbers are also allowed.
	GetBalance(context.Context, *ChainReaderRequest) (*Balance, error)
	// GetBlockByNumber returns the requested block. When blockNr is -1 the chain head is returned. When fullTx is true all
	// transactions in the block are returned in full detail, otherwise only the transaction hash is returned.
	GetBlockByNumber(context.Context, *BlockNumber) (*Block, error)
	// GetBlockByHash returns the requested block. When fullTx is true all transactions in the block are returned in full
	// detail, otherwise only the transaction hash is returned.
	GetBlockByHash(context.Context, *ChainReaderRequest) (*Block, error)
}

func RegisterChainReaderServer(s *grpc.Server, srv ChainReaderServer) {
	s.RegisterService(&_ChainReader_serviceDesc, srv)
}

func _ChainReader_GetBlockCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainReaderServer).GetBlockCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ChainReader/GetBlockCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainReaderServer).GetBlockCount(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainReader_GetBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainReaderServer).GetBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ChainReader/GetBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainReaderServer).GetBalance(ctx, req.(*ChainReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainReader_GetBlockByNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockNumber)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainReaderServer).GetBlockByNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ChainReader/GetBlockByNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainReaderServer).GetBlockByNumber(ctx, req.(*BlockNumber))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainReader_GetBlockByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainReaderServer).GetBlockByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.ChainReader/GetBlockByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainReaderServer).GetBlockByHash(ctx, req.(*ChainReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChainReader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.ChainReader",
	HandlerType: (*ChainReaderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBlockCount",
			Handler:    _ChainReader_GetBlockCount_Handler,
		},
		{
			MethodName: "GetBalance",
			Handler:    _ChainReader_GetBalance_Handler,
		},
		{
			MethodName: "GetBlockByNumber",
			Handler:    _ChainReader_GetBlockByNumber_Handler,
		},
		{
			MethodName: "GetBlockByHash",
			Handler:    _ChainReader_GetBlockByHash_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cpc.proto",
}

// TransactionPoolReaderClient is the client API for TransactionPoolReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type TransactionPoolReaderClient interface {
	GetTransactionCountByBlockNumber(ctx context.Context, in *BlockNumber, opts ...grpc.CallOption) (*TransactionCount, error)
	GetTransactionCountByBlockHash(ctx context.Context, in *BlockNumber, opts ...grpc.CallOption) (*TransactionCount, error)
	GetTransactionByBlockNumberAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*Transaction, error)
	GetTransactionByBlockHashAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*Transaction, error)
	GetRawTransactionByBlockNumberAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*Transaction, error)
	GetTransactionByHash(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*Transaction, error)
	GetTransactionReceipt(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*Transaction, error)
	GetTransactionCount(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*TransactionCount, error)
}

type transactionPoolReaderClient struct {
	cc *grpc.ClientConn
}

func NewTransactionPoolReaderClient(cc *grpc.ClientConn) TransactionPoolReaderClient {
	return &transactionPoolReaderClient{cc}
}

func (c *transactionPoolReaderClient) GetTransactionCountByBlockNumber(ctx context.Context, in *BlockNumber, opts ...grpc.CallOption) (*TransactionCount, error) {
	out := new(TransactionCount)
	err := c.cc.Invoke(ctx, "/protos.TransactionPoolReader/GetTransactionCountByBlockNumber", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionCountByBlockHash(ctx context.Context, in *BlockNumber, opts ...grpc.CallOption) (*TransactionCount, error) {
	out := new(TransactionCount)
	err := c.cc.Invoke(ctx, "/protos.TransactionPoolReader/GetTransactionCountByBlockHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionByBlockNumberAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*Transaction, error) {
	out := new(Transaction)
	err := c.cc.Invoke(ctx, "/protos.TransactionPoolReader/GetTransactionByBlockNumberAndIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionByBlockHashAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*Transaction, error) {
	out := new(Transaction)
	err := c.cc.Invoke(ctx, "/protos.TransactionPoolReader/GetTransactionByBlockHashAndIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetRawTransactionByBlockNumberAndIndex(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*Transaction, error) {
	out := new(Transaction)
	err := c.cc.Invoke(ctx, "/protos.TransactionPoolReader/GetRawTransactionByBlockNumberAndIndex", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionByHash(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*Transaction, error) {
	out := new(Transaction)
	err := c.cc.Invoke(ctx, "/protos.TransactionPoolReader/GetTransactionByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionReceipt(ctx context.Context, in *TransactionHash, opts ...grpc.CallOption) (*Transaction, error) {
	out := new(Transaction)
	err := c.cc.Invoke(ctx, "/protos.TransactionPoolReader/GetTransactionReceipt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transactionPoolReaderClient) GetTransactionCount(ctx context.Context, in *TransactionPoolReaderRequest, opts ...grpc.CallOption) (*TransactionCount, error) {
	out := new(TransactionCount)
	err := c.cc.Invoke(ctx, "/protos.TransactionPoolReader/GetTransactionCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TransactionPoolReaderServer is the server API for TransactionPoolReader service.
type TransactionPoolReaderServer interface {
	GetTransactionCountByBlockNumber(context.Context, *BlockNumber) (*TransactionCount, error)
	GetTransactionCountByBlockHash(context.Context, *BlockNumber) (*TransactionCount, error)
	GetTransactionByBlockNumberAndIndex(context.Context, *TransactionPoolReaderRequest) (*Transaction, error)
	GetTransactionByBlockHashAndIndex(context.Context, *TransactionPoolReaderRequest) (*Transaction, error)
	GetRawTransactionByBlockNumberAndIndex(context.Context, *TransactionPoolReaderRequest) (*Transaction, error)
	GetTransactionByHash(context.Context, *TransactionHash) (*Transaction, error)
	GetTransactionReceipt(context.Context, *TransactionHash) (*Transaction, error)
	GetTransactionCount(context.Context, *TransactionPoolReaderRequest) (*TransactionCount, error)
}

func RegisterTransactionPoolReaderServer(s *grpc.Server, srv TransactionPoolReaderServer) {
	s.RegisterService(&_TransactionPoolReader_serviceDesc, srv)
}

func _TransactionPoolReader_GetTransactionCountByBlockNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockNumber)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionCountByBlockNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.TransactionPoolReader/GetTransactionCountByBlockNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionCountByBlockNumber(ctx, req.(*BlockNumber))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionCountByBlockHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlockNumber)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionCountByBlockHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.TransactionPoolReader/GetTransactionCountByBlockHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionCountByBlockHash(ctx, req.(*BlockNumber))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionByBlockNumberAndIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionPoolReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionByBlockNumberAndIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.TransactionPoolReader/GetTransactionByBlockNumberAndIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionByBlockNumberAndIndex(ctx, req.(*TransactionPoolReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionByBlockHashAndIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionPoolReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionByBlockHashAndIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.TransactionPoolReader/GetTransactionByBlockHashAndIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionByBlockHashAndIndex(ctx, req.(*TransactionPoolReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetRawTransactionByBlockNumberAndIndex_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionPoolReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetRawTransactionByBlockNumberAndIndex(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.TransactionPoolReader/GetRawTransactionByBlockNumberAndIndex",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetRawTransactionByBlockNumberAndIndex(ctx, req.(*TransactionPoolReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.TransactionPoolReader/GetTransactionByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionByHash(ctx, req.(*TransactionHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionHash)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.TransactionPoolReader/GetTransactionReceipt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionReceipt(ctx, req.(*TransactionHash))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransactionPoolReader_GetTransactionCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TransactionPoolReaderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransactionPoolReaderServer).GetTransactionCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.TransactionPoolReader/GetTransactionCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransactionPoolReaderServer).GetTransactionCount(ctx, req.(*TransactionPoolReaderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _TransactionPoolReader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.TransactionPoolReader",
	HandlerType: (*TransactionPoolReaderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTransactionCountByBlockNumber",
			Handler:    _TransactionPoolReader_GetTransactionCountByBlockNumber_Handler,
		},
		{
			MethodName: "GetTransactionCountByBlockHash",
			Handler:    _TransactionPoolReader_GetTransactionCountByBlockHash_Handler,
		},
		{
			MethodName: "GetTransactionByBlockNumberAndIndex",
			Handler:    _TransactionPoolReader_GetTransactionByBlockNumberAndIndex_Handler,
		},
		{
			MethodName: "GetTransactionByBlockHashAndIndex",
			Handler:    _TransactionPoolReader_GetTransactionByBlockHashAndIndex_Handler,
		},
		{
			MethodName: "GetRawTransactionByBlockNumberAndIndex",
			Handler:    _TransactionPoolReader_GetRawTransactionByBlockNumberAndIndex_Handler,
		},
		{
			MethodName: "GetTransactionByHash",
			Handler:    _TransactionPoolReader_GetTransactionByHash_Handler,
		},
		{
			MethodName: "GetTransactionReceipt",
			Handler:    _TransactionPoolReader_GetTransactionReceipt_Handler,
		},
		{
			MethodName: "GetTransactionCount",
			Handler:    _TransactionPoolReader_GetTransactionCount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cpc.proto",
}

// CoinbaseClient is the client API for Coinbase service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CoinbaseClient interface {
	// Coinbase is the address that mining rewards will be send to (alias for Etherbase)
	Coinbase(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Address, error)
}

type coinbaseClient struct {
	cc *grpc.ClientConn
}

func NewCoinbaseClient(cc *grpc.ClientConn) CoinbaseClient {
	return &coinbaseClient{cc}
}

func (c *coinbaseClient) Coinbase(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Address, error) {
	out := new(Address)
	err := c.cc.Invoke(ctx, "/protos.Coinbase/Coinbase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CoinbaseServer is the server API for Coinbase service.
type CoinbaseServer interface {
	// Coinbase is the address that mining rewards will be send to (alias for Etherbase)
	Coinbase(context.Context, *empty.Empty) (*Address, error)
}

func RegisterCoinbaseServer(s *grpc.Server, srv CoinbaseServer) {
	s.RegisterService(&_Coinbase_serviceDesc, srv)
}

func _Coinbase_Coinbase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoinbaseServer).Coinbase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.Coinbase/Coinbase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoinbaseServer).Coinbase(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _Coinbase_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.Coinbase",
	HandlerType: (*CoinbaseServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Coinbase",
			Handler:    _Coinbase_Coinbase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cpc.proto",
}

// MinerReaderClient is the client API for MinerReader service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MinerReaderClient interface {
	// Coinbase is the address that mining rewards will be send to (alias for Etherbase)
	Mining(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsOk, error)
	// GetWork returns a work package for external miner. The work package consists of 3 strings
	// result[0], 32 bytes hex encoded current block header pow-hash
	// result[1], 32 bytes hex encoded seed hash used for DAG
	// result[2], 32 bytes hex encoded boundary condition ("target"), 2^256/difficulty
	GetWork(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Works, error)
}

type minerReaderClient struct {
	cc *grpc.ClientConn
}

func NewMinerReaderClient(cc *grpc.ClientConn) MinerReaderClient {
	return &minerReaderClient{cc}
}

func (c *minerReaderClient) Mining(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*IsOk, error) {
	out := new(IsOk)
	err := c.cc.Invoke(ctx, "/protos.MinerReader/Mining", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *minerReaderClient) GetWork(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*Works, error) {
	out := new(Works)
	err := c.cc.Invoke(ctx, "/protos.MinerReader/GetWork", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MinerReaderServer is the server API for MinerReader service.
type MinerReaderServer interface {
	// Coinbase is the address that mining rewards will be send to (alias for Etherbase)
	Mining(context.Context, *empty.Empty) (*IsOk, error)
	// GetWork returns a work package for external miner. The work package consists of 3 strings
	// result[0], 32 bytes hex encoded current block header pow-hash
	// result[1], 32 bytes hex encoded seed hash used for DAG
	// result[2], 32 bytes hex encoded boundary condition ("target"), 2^256/difficulty
	GetWork(context.Context, *empty.Empty) (*Works, error)
}

func RegisterMinerReaderServer(s *grpc.Server, srv MinerReaderServer) {
	s.RegisterService(&_MinerReader_serviceDesc, srv)
}

func _MinerReader_Mining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerReaderServer).Mining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.MinerReader/Mining",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerReaderServer).Mining(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MinerReader_GetWork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerReaderServer).GetWork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protos.MinerReader/GetWork",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerReaderServer).GetWork(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _MinerReader_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protos.MinerReader",
	HandlerType: (*MinerReaderServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Mining",
			Handler:    _MinerReader_Mining_Handler,
		},
		{
			MethodName: "GetWork",
			Handler:    _MinerReader_GetWork_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cpc.proto",
}
