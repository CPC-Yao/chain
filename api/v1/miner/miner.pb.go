// Code generated by protoc-gen-go. DO NOT EDIT.
// source: v1/miner/miner.proto

package minerpb

import (
	commonpb "bitbucket.org/cpchain/chain/api/v1/commonpb"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	empty "github.com/golang/protobuf/ptypes/empty"
	context "golang.org/x/net/context"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Threads represents the number of threads opened.
type Threads struct {
	Threads              int32    `protobuf:"varint,1,opt,name=threads,proto3" json:"threads,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Threads) Reset()         { *m = Threads{} }
func (m *Threads) String() string { return proto.CompactTextString(m) }
func (*Threads) ProtoMessage()    {}
func (*Threads) Descriptor() ([]byte, []int) {
	return fileDescriptor_b21951bc0eada822, []int{0}
}

func (m *Threads) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Threads.Unmarshal(m, b)
}
func (m *Threads) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Threads.Marshal(b, m, deterministic)
}
func (m *Threads) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Threads.Merge(m, src)
}
func (m *Threads) XXX_Size() int {
	return xxx_messageInfo_Threads.Size(m)
}
func (m *Threads) XXX_DiscardUnknown() {
	xxx_messageInfo_Threads.DiscardUnknown(m)
}

var xxx_messageInfo_Threads proto.InternalMessageInfo

func (m *Threads) GetThreads() int32 {
	if m != nil {
		return m.Threads
	}
	return 0
}

// ExTra the extra data string that is included when this miner mines a block.
type Extra struct {
	Extra                string   `protobuf:"bytes,1,opt,name=extra,proto3" json:"extra,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Extra) Reset()         { *m = Extra{} }
func (m *Extra) String() string { return proto.CompactTextString(m) }
func (*Extra) ProtoMessage()    {}
func (*Extra) Descriptor() ([]byte, []int) {
	return fileDescriptor_b21951bc0eada822, []int{1}
}

func (m *Extra) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Extra.Unmarshal(m, b)
}
func (m *Extra) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Extra.Marshal(b, m, deterministic)
}
func (m *Extra) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Extra.Merge(m, src)
}
func (m *Extra) XXX_Size() int {
	return xxx_messageInfo_Extra.Size(m)
}
func (m *Extra) XXX_DiscardUnknown() {
	xxx_messageInfo_Extra.DiscardUnknown(m)
}

var xxx_messageInfo_Extra proto.InternalMessageInfo

func (m *Extra) GetExtra() string {
	if m != nil {
		return m.Extra
	}
	return ""
}

func init() {
	proto.RegisterType((*Threads)(nil), "miner.Threads")
	proto.RegisterType((*Extra)(nil), "miner.Extra")
}

func init() { proto.RegisterFile("v1/miner/miner.proto", fileDescriptor_b21951bc0eada822) }

var fileDescriptor_b21951bc0eada822 = []byte{
	// 347 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x90, 0x4f, 0x4e, 0xf3, 0x30,
	0x10, 0xc5, 0x95, 0xef, 0x23, 0x94, 0x9a, 0x0a, 0x90, 0xa9, 0x4a, 0x48, 0x69, 0x05, 0x86, 0x05,
	0xea, 0x22, 0x51, 0x61, 0xd7, 0x1d, 0xa0, 0x0a, 0x55, 0xa8, 0x2a, 0x6a, 0x58, 0xb1, 0x73, 0x5a,
	0x53, 0x22, 0x88, 0x6d, 0xd9, 0xa6, 0x82, 0x2d, 0x57, 0xe0, 0x02, 0xdc, 0x89, 0x2b, 0x70, 0x10,
	0xe4, 0x7f, 0x2c, 0x82, 0x90, 0xd8, 0x44, 0xf3, 0x3c, 0xf3, 0x7e, 0x79, 0x33, 0xa0, 0xb9, 0xec,
	0xa7, 0x65, 0x41, 0x89, 0xb0, 0xdf, 0x84, 0x0b, 0xa6, 0x18, 0x0c, 0x8d, 0x88, 0xa3, 0x65, 0x3f,
	0x9d, 0xb1, 0xb2, 0x64, 0x94, 0xe7, 0xae, 0xb0, 0x03, 0x71, 0x7b, 0xc1, 0xd8, 0xe2, 0x91, 0xa4,
	0x46, 0xe5, 0x4f, 0x77, 0x29, 0x29, 0xb9, 0x7a, 0x71, 0xcd, 0x3d, 0xd7, 0xc4, 0xbc, 0x48, 0x31,
	0xa5, 0x4c, 0x61, 0x55, 0x30, 0x2a, 0x6d, 0x17, 0x1d, 0x82, 0xda, 0xcd, 0xbd, 0x20, 0x78, 0x2e,
	0x61, 0x04, 0x6a, 0xca, 0x96, 0x51, 0xb0, 0x1f, 0x1c, 0x87, 0x53, 0x2f, 0x51, 0x07, 0x84, 0xc3,
	0x67, 0x25, 0x30, 0x6c, 0x82, 0x90, 0xe8, 0xc2, 0x0c, 0xd4, 0xa7, 0x56, 0x9c, 0xbc, 0xff, 0x07,
	0x8d, 0xb1, 0x8e, 0x38, 0xc6, 0x14, 0x2f, 0x88, 0x80, 0x13, 0x10, 0x66, 0x0a, 0x0b, 0x05, 0x37,
	0x12, 0xbb, 0x87, 0xfb, 0x45, 0xdc, 0x4a, 0x6c, 0x98, 0xc4, 0x27, 0x4d, 0x86, 0x3a, 0x29, 0xea,
	0xbe, 0x7e, 0x7c, 0xbe, 0xfd, 0x8b, 0xd0, 0xb6, 0x49, 0xf9, 0x7d, 0x04, 0xa9, 0x21, 0x83, 0xa0,
	0x07, 0xaf, 0xc0, 0x4a, 0xa6, 0x18, 0x87, 0xbf, 0xf8, 0xe3, 0x46, 0xe2, 0xee, 0x31, 0x92, 0x93,
	0x07, 0xd4, 0x31, 0xb4, 0x1d, 0x04, 0xab, 0x34, 0xc6, 0x35, 0x6c, 0x04, 0xd6, 0x32, 0xa2, 0xec,
	0x42, 0x0d, 0x17, 0xd0, 0xa8, 0x0a, 0xe6, 0xc0, 0x60, 0xda, 0xa8, 0x55, 0xc1, 0x38, 0xaf, 0x46,
	0x65, 0x60, 0x3d, 0x23, 0xea, 0x12, 0xcb, 0x6b, 0x51, 0xcc, 0x08, 0xdc, 0xf2, 0x7e, 0xff, 0x52,
	0x21, 0x1e, 0x19, 0x62, 0x17, 0xed, 0xfe, 0x20, 0x7a, 0x83, 0x86, 0x4e, 0x0d, 0xf4, 0x82, 0x15,
	0x34, 0xc7, 0x92, 0xc0, 0x4d, 0x8f, 0x38, 0x9b, 0xcf, 0x05, 0x91, 0xf2, 0xcf, 0x4c, 0x4f, 0x18,
	0x04, 0xbd, 0xf3, 0xfa, 0x6d, 0xcd, 0xbc, 0xf3, 0x3c, 0x5f, 0x35, 0xb7, 0x3b, 0xfd, 0x0a, 0x00,
	0x00, 0xff, 0xff, 0x83, 0x27, 0x30, 0x4f, 0x6c, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MinerManagerClient is the client API for MinerManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MinerManagerClient interface {
	// Start the miner with the given number of threads. If threads is nil the number
	// of workers started is equal to the number of logical CPUs that are usable by
	// this process. If mining is already running, this method adjust the number of
	// threads allowed to use.
	Start(ctx context.Context, in *Threads, opts ...grpc.CallOption) (*empty.Empty, error)
	//    Stop the miner
	Stop(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*commonpb.IsOk, error)
	// SetExtra sets the extra data string that is included when this miner mines a block.
	SetExtra(ctx context.Context, in *Extra, opts ...grpc.CallOption) (*commonpb.IsOk, error)
	// SetGasPrice sets the minimum accepted gas price for the miner.
	SetGasPrice(ctx context.Context, in *commonpb.GasPrice, opts ...grpc.CallOption) (*commonpb.IsOk, error)
	// SetCoinbase sets the coinbase of the miner
	SetCoinbase(ctx context.Context, in *commonpb.Address, opts ...grpc.CallOption) (*commonpb.IsOk, error)
}

type minerManagerClient struct {
	cc *grpc.ClientConn
}

func NewMinerManagerClient(cc *grpc.ClientConn) MinerManagerClient {
	return &minerManagerClient{cc}
}

func (c *minerManagerClient) Start(ctx context.Context, in *Threads, opts ...grpc.CallOption) (*empty.Empty, error) {
	out := new(empty.Empty)
	err := c.cc.Invoke(ctx, "/miner.MinerManager/Start", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *minerManagerClient) Stop(ctx context.Context, in *empty.Empty, opts ...grpc.CallOption) (*commonpb.IsOk, error) {
	out := new(commonpb.IsOk)
	err := c.cc.Invoke(ctx, "/miner.MinerManager/Stop", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *minerManagerClient) SetExtra(ctx context.Context, in *Extra, opts ...grpc.CallOption) (*commonpb.IsOk, error) {
	out := new(commonpb.IsOk)
	err := c.cc.Invoke(ctx, "/miner.MinerManager/SetExtra", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *minerManagerClient) SetGasPrice(ctx context.Context, in *commonpb.GasPrice, opts ...grpc.CallOption) (*commonpb.IsOk, error) {
	out := new(commonpb.IsOk)
	err := c.cc.Invoke(ctx, "/miner.MinerManager/SetGasPrice", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *minerManagerClient) SetCoinbase(ctx context.Context, in *commonpb.Address, opts ...grpc.CallOption) (*commonpb.IsOk, error) {
	out := new(commonpb.IsOk)
	err := c.cc.Invoke(ctx, "/miner.MinerManager/SetCoinbase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MinerManagerServer is the server API for MinerManager service.
type MinerManagerServer interface {
	// Start the miner with the given number of threads. If threads is nil the number
	// of workers started is equal to the number of logical CPUs that are usable by
	// this process. If mining is already running, this method adjust the number of
	// threads allowed to use.
	Start(context.Context, *Threads) (*empty.Empty, error)
	//    Stop the miner
	Stop(context.Context, *empty.Empty) (*commonpb.IsOk, error)
	// SetExtra sets the extra data string that is included when this miner mines a block.
	SetExtra(context.Context, *Extra) (*commonpb.IsOk, error)
	// SetGasPrice sets the minimum accepted gas price for the miner.
	SetGasPrice(context.Context, *commonpb.GasPrice) (*commonpb.IsOk, error)
	// SetCoinbase sets the coinbase of the miner
	SetCoinbase(context.Context, *commonpb.Address) (*commonpb.IsOk, error)
}

func RegisterMinerManagerServer(s *grpc.Server, srv MinerManagerServer) {
	s.RegisterService(&_MinerManager_serviceDesc, srv)
}

func _MinerManager_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Threads)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerManagerServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/miner.MinerManager/Start",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerManagerServer).Start(ctx, req.(*Threads))
	}
	return interceptor(ctx, in, info, handler)
}

func _MinerManager_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(empty.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerManagerServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/miner.MinerManager/Stop",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerManagerServer).Stop(ctx, req.(*empty.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _MinerManager_SetExtra_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Extra)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerManagerServer).SetExtra(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/miner.MinerManager/SetExtra",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerManagerServer).SetExtra(ctx, req.(*Extra))
	}
	return interceptor(ctx, in, info, handler)
}

func _MinerManager_SetGasPrice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(commonpb.GasPrice)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerManagerServer).SetGasPrice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/miner.MinerManager/SetGasPrice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerManagerServer).SetGasPrice(ctx, req.(*commonpb.GasPrice))
	}
	return interceptor(ctx, in, info, handler)
}

func _MinerManager_SetCoinbase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(commonpb.Address)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MinerManagerServer).SetCoinbase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/miner.MinerManager/SetCoinbase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MinerManagerServer).SetCoinbase(ctx, req.(*commonpb.Address))
	}
	return interceptor(ctx, in, info, handler)
}

var _MinerManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "miner.MinerManager",
	HandlerType: (*MinerManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Start",
			Handler:    _MinerManager_Start_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _MinerManager_Stop_Handler,
		},
		{
			MethodName: "SetExtra",
			Handler:    _MinerManager_SetExtra_Handler,
		},
		{
			MethodName: "SetGasPrice",
			Handler:    _MinerManager_SetGasPrice_Handler,
		},
		{
			MethodName: "SetCoinbase",
			Handler:    _MinerManager_SetCoinbase_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "v1/miner/miner.proto",
}
